{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SignedMathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMathUpgradeable {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SignedMathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMathUpgradeable.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/Delegation/IOperatorDelegator.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../EigenLayer/interfaces/IStrategyManager.sol\";\nimport \"../EigenLayer/interfaces/IDelegationManager.sol\";\nimport \"../EigenLayer/interfaces/IEigenPod.sol\";\n\ninterface IOperatorDelegator {\n    function getTokenBalanceFromStrategy(\n        IERC20 token\n    ) external view returns (uint256);\n\n    function deposit(IERC20 _token, uint256 _tokenAmount) external returns (uint256 shares);\n\n    function startWithdrawal(\n        IERC20 _token,\n        uint256 _tokenAmount\n    ) external returns (bytes32);\n\n    function completeWithdrawal(\n        IStrategyManager.QueuedWithdrawal calldata _withdrawal,\n        IERC20 _token,\n        uint256 _middlewareTimesIndex,\n        address _sendToAddress\n    ) external;\n\n    function getStakedETHBalance() external view returns (uint256);\n\n    function stakeEth(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n\n    function eigenPod() external view returns (IEigenPod);\n}\n\n\n"
    },
    "contracts/Delegation/OperatorDelegator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../Permissions/IRoleManager.sol\";\nimport \"./OperatorDelegatorStorage.sol\";\nimport \"../RestakeManager.sol\";\nimport \"../EigenLayer/interfaces/IDelegationManager.sol\";\nimport \"../Errors/Errors.sol\";\n\n/// @dev This contract will be responsible for interacting with Eigenlayer\n/// Each of these contracts deployed will be delegated to one specific operator\n/// This contract can handle multiple ERC20 tokens, all of which will be delegated to the same operator\n/// Each supported ERC20 token will be pointed at a single Strategy contract in EL\n/// Only the RestakeManager should be interacting with this contract for EL interactions.\ncontract OperatorDelegator is\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    OperatorDelegatorStorageV1\n{\n    using SafeERC20 for IERC20;\n    \n    uint256 internal constant GWEI_TO_WEI = 1e9;\n\n    event TokenStrategyUpdated(IERC20 token, IStrategy strategy);\n    event DelegationAddressUpdated(address delegateAddress);\n\n    event WithdrawStarted(\n        bytes32 withdrawRoot,\n        address staker,\n        address delegatedTo,\n        address withdrawer,\n        uint nonce,\n        uint startBlock,\n        IStrategy[] strategies,\n        uint256[] shares\n    );\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyOperatorDelegatorAdmin() {\n        if(!roleManager.isOperatorDelegatorAdmin(msg.sender)) revert NotOperatorDelegatorAdmin();\n        _;\n    }\n\n    /// @dev Allows only the RestakeManager address to call functions\n    modifier onlyRestakeManager() {\n        if(msg.sender != restakeManager) revert NotRestakeManager();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyNativeEthRestakeAdmin() {\n        if(!roleManager.isNativeEthRestakeAdmin(msg.sender)) revert NotNativeEthRestakeAdmin();\n        _;\n    }\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(\n        IRoleManager _roleManager,\n        IStrategyManager _strategyManager,\n        address _restakeManager,\n        IDelegationManager _delegationManager,\n        IEigenPodManager _eigenPodManager\n    ) external initializer {\n        if(address(_roleManager) == address(0x0)) revert InvalidZeroInput();\n        if(address(_strategyManager) == address(0x0)) revert InvalidZeroInput();\n        if(address(_restakeManager) == address(0x0)) revert InvalidZeroInput();\n        if(address(_delegationManager) == address(0x0)) revert InvalidZeroInput();\n        if(address(_eigenPodManager) == address(0x0)) revert InvalidZeroInput();\n\n        __ReentrancyGuard_init();\n\n        roleManager = _roleManager;\n        strategyManager = _strategyManager;\n        restakeManager = _restakeManager;\n        delegationManager = _delegationManager;\n        eigenPodManager = _eigenPodManager;\n\n        // Deploy new EigenPod\n        eigenPodManager.createPod();\n\n        // Save off the EigenPod address\n        eigenPod = IEigenPod(eigenPodManager.ownerToPod(address(this)));\n    }\n\n    /// @dev Sets the strategy for a given token - setting strategy to 0x0 removes the ability to deposit and withdraw token\n    function setTokenStrategy(\n        IERC20 _token,\n        IStrategy _strategy\n    ) external nonReentrant onlyOperatorDelegatorAdmin {\n        if(address(_token) == address(0x0)) revert InvalidZeroInput();\n\n        tokenStrategyMapping[_token] = _strategy;\n        emit TokenStrategyUpdated(_token, _strategy);\n    }\n\n    /// @dev Sets the address to delegate tokens to in EigenLayer -- THIS CAN ONLY BE SET ONCE\n    function setDelegateAddress(\n        address _delegateAddress\n    ) external nonReentrant onlyOperatorDelegatorAdmin {\n        if(address(_delegateAddress) == address(0x0)) revert InvalidZeroInput();\n        if(address(delegateAddress) != address(0x0)) revert DelegateAddressAlreadySet();\n\n        delegateAddress = _delegateAddress;\n\n        delegationManager.delegateTo(\n            delegateAddress\n        );\n\n        emit DelegationAddressUpdated(_delegateAddress);\n    }\n\n    /// @dev Deposit tokens into the EigenLayer.  This call assumes any balance of tokens in this contract will be delegated\n    /// so do not directly send tokens here or they will be delegated and attributed to the next caller.\n    /// @return shares The amount of new shares in the `strategy` created as part of the action.\n    function deposit(\n        IERC20 _token,\n        uint256 _tokenAmount\n    ) external nonReentrant onlyRestakeManager returns (uint256 shares) {\n        if(address(tokenStrategyMapping[_token]) == address(0x0)) revert InvalidZeroInput();\n        if(_tokenAmount == 0) revert InvalidZeroInput();\n\n        // Move the tokens into this contract\n        _token.safeTransferFrom(msg.sender, address(this), _tokenAmount);\n\n        // Approve the strategy manager to spend the tokens\n        _token.safeApprove(address(strategyManager), _tokenAmount);\n\n        // Deposit the tokens via the strategy manager\n        return\n            strategyManager.depositIntoStrategy(\n                tokenStrategyMapping[_token],\n                _token,\n                _tokenAmount\n            );\n    }\n\n    /// @dev Gets the index of the specific strategy in EigenLayer in the staker's strategy list\n    function getStrategyIndex(IStrategy _strategy) public view returns (uint256) {\n        // Get the length of the strategy list for this contract\n        uint256 strategyLength = strategyManager.stakerStrategyListLength(address(this));\n\n        for(uint256 i = 0; i < strategyLength; i++) {\n            if(strategyManager.stakerStrategyList(address(this), i) == _strategy) {\n                return i;\n            }\n        }\n\n        // Not found\n        revert NotFound();\n    }\n\n    /// @dev Starts a withdrawal of a specific token from the EigenLayer.\n    /// @param _token The token to withdraw from the EigenLayer.\n    /// @param _tokenAmount The amount of tokens to withdraw.\n    function startWithdrawal(\n        IERC20 _token,\n        uint256 _tokenAmount\n    ) external nonReentrant onlyRestakeManager returns (bytes32) {\n        if(address(tokenStrategyMapping[_token]) == address(0x0)) revert InvalidZeroInput();\n\n        // Save the nonce before starting the withdrawal\n        uint96 nonce = uint96(strategyManager.numWithdrawalsQueued(address(this)));\n\n        // Need to get the index for the strategy - this is not ideal since docs say only to put into list ones that we are withdrawing 100% from\n        uint256[] memory strategyIndexes = new uint256[](1);\n        strategyIndexes[0] = getStrategyIndex(tokenStrategyMapping[_token]);\n\n        // Convert the number of tokens to shares - TODO: Understand if the view function is the proper one to call\n        uint256 sharesToWithdraw = tokenStrategyMapping[_token].underlyingToSharesView(_tokenAmount);\n\n        IStrategy[] memory strategiesToWithdraw = new IStrategy[](1);\n        strategiesToWithdraw[0] = tokenStrategyMapping[_token];\n\n        uint256[] memory amountsToWithdraw = new uint256[](1);\n        amountsToWithdraw[0] = sharesToWithdraw;\n\n        bytes32 withdrawalRoot = strategyManager.queueWithdrawal(\n            strategyIndexes,\n            strategiesToWithdraw,\n            amountsToWithdraw,\n            address(this), // Only allow this contract to complete the withdraw\n            false // Do not undeledgate if the balance goes to 0\n        );\n\n        // Emit the withdrawal started event\n        emit WithdrawStarted(\n            withdrawalRoot,\n            address(this),\n            delegateAddress,\n            address(this),\n            nonce,\n            block.number,\n            strategiesToWithdraw,\n            amountsToWithdraw\n        );\n\n        return withdrawalRoot;\n    }\n\n    /// @dev Completes a withdrawal of a specific token from the EigenLayer.\n    /// The tokens withdrawn will be sent directly to the specified address\n    function completeWithdrawal(\n        IStrategyManager.QueuedWithdrawal calldata _withdrawal,\n        IERC20 _token,\n        uint256 _middlewareTimesIndex,\n        address _sendToAddress\n    ) external nonReentrant onlyRestakeManager {\n        IERC20[] memory tokens = new IERC20[](1);\n        tokens[0] = _token;\n\n        strategyManager.completeQueuedWithdrawal(\n            _withdrawal,\n            tokens,\n            _middlewareTimesIndex,\n            true // Always get tokens and not share transfers\n        );\n\n        // Send tokens to the specified address\n        _token.safeTransfer(_sendToAddress, _token.balanceOf(address(this)));\n    }\n\n    /// @dev Gets the underlying token amount from the amount of shares\n    function getTokenBalanceFromStrategy(\n        IERC20 token\n    ) external view returns (uint256) {\n        return tokenStrategyMapping[token].userUnderlyingView(address(this));\n    }\n\n    /// @dev Gets the amount of ETH staked in the EigenLayer\n    function getStakedETHBalance() external view returns (uint256) {\n        // TODO: Once withdrawals are enabled, allow this to handle pending withdraws and a potential negative share balance in the EigenPodManager ownershares        \n        // TODO: Once upgraded to M2, add back in staked verified ETH, e.g. + uint256(strategyManager.stakerStrategyShares(address(this), strategyManager.beaconChainETHStrategy()))\n        return stakedButNotVerifiedEth + address(eigenPod).balance;\n    }\n\n    /// @dev Stake ETH in the EigenLayer\n    /// Only the Restake Manager should call this function\n    function stakeEth(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable onlyRestakeManager {\n        // Call the stake function in the EigenPodManager\n        eigenPodManager.stake{value: msg.value}(pubkey, signature, depositDataRoot);\n\n        // Increment the staked but not verified ETH\n        stakedButNotVerifiedEth += msg.value;\n    }\n\n    /// @dev Verifies the withdrawal credentials for a withdrawal\n    /// This will allow the EigenPodManager to verify the withdrawal credentials and credit the OD with shares\n    /// Only the native eth restake admin should call this function\n    function verifyWithdrawalCredentials(\n        uint64 oracleBlockNumber,\n        uint40 validatorIndex,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs memory proofs,\n        bytes32[] calldata validatorFields\n    ) external onlyNativeEthRestakeAdmin {\n        eigenPod.verifyWithdrawalCredentialsAndBalance(\n            oracleBlockNumber,\n            validatorIndex,\n            proofs,\n            validatorFields\n        );\n\n        // Decrement the staked but not verified ETH\n        uint64 validatorCurrentBalanceGwei = BeaconChainProofs.getBalanceFromBalanceRoot(validatorIndex, proofs.balanceRoot);\n        stakedButNotVerifiedEth -= (validatorCurrentBalanceGwei * GWEI_TO_WEI);\n    }\n}\n"
    },
    "contracts/Delegation/OperatorDelegatorStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"../Permissions/IRoleManager.sol\";\nimport \"../EigenLayer/interfaces/IStrategy.sol\";\nimport \"../EigenLayer/interfaces/IStrategyManager.sol\";\nimport \"../EigenLayer/interfaces/IDelegationManager.sol\";\nimport \"../EigenLayer/interfaces/IEigenPod.sol\";\nimport \"./IOperatorDelegator.sol\";\n\n/// @title OperatorDelegatorStorage\n/// @dev This contract will hold all local variables for the  Contract\n/// When upgrading the protocol, inherit from this contract on the V2 version and change the\n/// StorageManager to inherit from the later version.  This ensures there are no storage layout\n/// corruptions when upgrading.\nabstract contract OperatorDelegatorStorageV1 is IOperatorDelegator{\n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev The main strategy manager contract in EigenLayer\n    IStrategyManager public strategyManager;\n\n    /// @dev the restake manager contract\n    address public restakeManager;\n\n    /// @dev The mapping of supported token addresses to their respective strategy addresses\n    /// This will control which tokens are supported by the protocol\n    mapping(IERC20 => IStrategy) public tokenStrategyMapping;\n\n    /// @dev The address to delegate tokens to in EigenLayer\n    address public delegateAddress;\n\n    /// @dev the delegation manager contract\n    IDelegationManager public delegationManager;\n\n    /// @dev the EigenLayer EigenPodManager contract\n    IEigenPodManager public eigenPodManager;\n\n    /// @dev The EigenPod owned by this contract\n    IEigenPod public eigenPod;\n\n    /// @dev Tracks the balance that was staked to validators but hasn't been restaked to EL yet\n    uint256 public stakedButNotVerifiedEth;\n}\n\n/// On the next version of the protocol, if new variables are added, put them in the below\n/// contract and use this as the inheritance chain.\n// contract OperatorDelegatorStorageV2 is OperatorDelegatorStorageV1 {\n// }\n"
    },
    "contracts/Deposits/DepositQueue.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./DepositQueueStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../Errors/Errors.sol\";\n\n\ncontract DepositQueue is Initializable, ReentrancyGuardUpgradeable, DepositQueueStorageV1 {\n\n    using SafeERC20 for IERC20;\n\n    event RewardsDeposited(\n        IERC20 token,\n        uint256 amount\n    );\n\n    event FeeConfigUpdated(\n        address feeAddress,\n        uint256 feeBasisPoints\n    );\n\n    event RestakeManagerUpdated(\n        IRestakeManager restakeManager\n    );\n\n    event ETHDepositedFromProtocol(\n        uint256 amount\n    );\n\n    event ETHStakedFromQueue(\n        IOperatorDelegator operatorDelegator,\n        bytes pubkey,\n        uint256 amountStaked,\n        uint256 amountQueued\n    );\n\n    event ProtocolFeesPaid(\n        IERC20 token,\n        uint256 amount,\n        address destination\n    );\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyRestakeManagerAdmin() {\n        if(!roleManager.isRestakeManagerAdmin(msg.sender)) revert NotRestakeManagerAdmin();\n        _;\n    }\n\n    /// @dev Allows only the RestakeManager address to call functions\n    modifier onlyRestakeManager() {\n        if(msg.sender != address(restakeManager)) revert NotRestakeManager();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to trigger native ETH staking\n    modifier onlyNativeEthRestakeAdmin() {\n        if(!roleManager.isNativeEthRestakeAdmin(msg.sender)) revert NotNativeEthRestakeAdmin();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to trigger ERC20 rewards sweeping\n    modifier onlyERC20RewardsAdmin() {\n        if(!roleManager.isERC20RewardsAdmin(msg.sender)) revert NotERC20RewardsAdmin();\n        _;\n    }\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(IRoleManager _roleManager) public initializer {\n        __ReentrancyGuard_init();\n\n        if(address(_roleManager) == address(0x0)) revert InvalidZeroInput(); \n        \n        roleManager = _roleManager;   \n    }\n\n    /// @dev Sets the config for fees - if either value is set to 0 then fees are disabled\n    function setFeeConfig(address _feeAddress, uint256 _feeBasisPoints) external onlyRestakeManagerAdmin {\n        // Verify address is set if basis points are non-zero\n        if(_feeBasisPoints > 0) {\n            if(_feeAddress == address(0x0)) revert InvalidZeroInput();\n        }\n\n        // Verify basis points are not over 100%\n        if(_feeBasisPoints > 10000) revert OverMaxBasisPoints();\n\n        feeAddress = _feeAddress;\n        feeBasisPoints = _feeBasisPoints;\n\n        emit FeeConfigUpdated(_feeAddress, _feeBasisPoints);\n    }\n\n    /// @dev Sets the address of the RestakeManager contract\n    function setRestakeManager(IRestakeManager _restakeManager) external onlyRestakeManagerAdmin {\n        if(address(_restakeManager) == address(0x0)) revert InvalidZeroInput();\n\n        restakeManager = _restakeManager;\n\n        emit RestakeManagerUpdated(_restakeManager);\n    }\n\n    /// @dev Handle ETH sent to the protocol through the RestakeManager - e.g. user deposits\n    /// ETH will be stored here until used for a validator deposit\n    function depositETHFromProtocol() external payable onlyRestakeManager {\n        emit ETHDepositedFromProtocol(msg.value);\n    }\n\n    /// @dev Handle ETH sent to this contract from outside the protocol - e.g. rewards\n    /// ETH will be stored here until used for a validator deposit\n    /// This should receive ETH from scenarios like Execution Layer Rewards and MEV from native staking\n    /// Users should NOT send ETH directly to this contract unless they want to donate to existing ezETH holders\n    receive() external payable nonReentrant { \n        uint256 feeAmount = 0;\n        // Take protocol cut of rewards if enabled\n        if(feeAddress != address(0x0) && feeBasisPoints > 0) {\n            feeAmount = msg.value * feeBasisPoints / 10000;\n            (bool success, ) = feeAddress.call{value: feeAmount}(\"\");\n            if(!success) revert TransferFailed();\n\n            emit ProtocolFeesPaid(IERC20(address(0x0)), feeAmount, feeAddress);\n        } \n\n        // Add to the total earned\n        totalEarned[address(0x0)] = totalEarned[address(0x0)] + msg.value - feeAmount;\n\n        // Emit the rewards event\n        emit RewardsDeposited(IERC20(address(0x0)), msg.value - feeAmount);\n    }\n\n    /// @dev Function called by ETH Restake Admin to start the restaking process in Native ETH\n    /// Only callable by a permissioned account\n    function stakeEthFromQueue(IOperatorDelegator operatorDelegator, bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external onlyNativeEthRestakeAdmin {\n\n        // Send the ETH and the params through to the restake manager\n        restakeManager.stakeEthInOperatorDelegator{value: 32 ether}(operatorDelegator, pubkey, signature, depositDataRoot);\n\n        emit ETHStakedFromQueue(operatorDelegator, pubkey, 32 ether, address(this).balance);\n    }\n\n    /// @dev Sweeps any accumulated ERC20 tokens in this contract to the RestakeManager\n    /// Only callable by a permissioned account\n    function sweepERC20(IERC20 token) external onlyERC20RewardsAdmin {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        if(balance > 0) {\n            uint256 feeAmount = 0;\n\n            // Sweep fees if configured\n            if(feeAddress != address(0x0) && feeBasisPoints > 0) {\n                feeAmount = balance * feeBasisPoints / 10000;\n                IERC20(token).safeTransfer(feeAddress, feeAmount);\n\n                emit ProtocolFeesPaid(token, feeAmount, feeAddress);\n            }\n\n            // Approve and deposit the rewards\n            token.approve(address(restakeManager), balance - feeAmount);\n            restakeManager.depositTokenRewardsFromProtocol(token, balance - feeAmount);\n\n            // Add to the total earned\n            totalEarned[address(token)] = totalEarned[address(token)] + balance - feeAmount;\n\n            // Emit the rewards event\n            emit RewardsDeposited(IERC20(address(token)), balance - feeAmount);\n        }\n    }\n}"
    },
    "contracts/Deposits/DepositQueueStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"../Permissions/IRoleManager.sol\";\nimport \"../IRestakeManager.sol\";\nimport \"./IDepositQueue.sol\";\n\nabstract contract DepositQueueStorageV1 is IDepositQueue {    \n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev the address of the RestakeManager contract\n    IRestakeManager public restakeManager;\n\n    /// @dev the address where fees will be sent - must be non zero to enable fees\n    address public feeAddress;\n\n    /// @dev the basis points to charge for fees - 100 basis points = 1%\n    uint256 public feeBasisPoints;\n\n    /// @dev the total amount the protocol has earned - token address => amount\n    mapping(address => uint256) public totalEarned;\n}\n"
    },
    "contracts/Deposits/IDepositQueue.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IDepositQueue {\n  function depositETHFromProtocol() external payable;\n  function totalEarned(address tokenAddress) external view returns(uint256);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IBeaconChainOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Interface for the BeaconStateOracle contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IBeaconChainOracle {\n    /// @notice Largest blockNumber that has been confirmed by the oracle.\n    function latestConfirmedOracleBlockNumber() external view returns(uint64);\n    /// @notice Mapping: Beacon Chain blockNumber => the Beacon Chain state root at the specified blockNumber.\n    /// @dev This will return `bytes32(0)` if the state root at the specified blockNumber is not yet confirmed.\n    function beaconStateRootAtBlockNumber(uint64 blockNumber) external view returns(bytes32);\n\n    /// @notice Mapping: address => whether or not the address is in the set of oracle signers.\n    function isOracleSigner(address _oracleSigner) external view returns(bool);\n\n    /// @notice Mapping: Beacon Chain blockNumber => oracle signer address => whether or not the oracle signer has voted on the state root at the blockNumber.\n    function hasVoted(uint64 blockNumber, address oracleSigner) external view returns(bool);\n\n    /// @notice Mapping: Beacon Chain blockNumber => state root => total number of oracle signer votes for the state root at the blockNumber. \n    function stateRootVotes(uint64 blockNumber, bytes32 stateRoot) external view returns(uint256);\n\n    /// @notice Total number of members of the set of oracle signers.\n    function totalOracleSigners() external view returns(uint256);\n\n    /**\n     * @notice Number of oracle signers that must vote for a state root in order for the state root to be confirmed.\n     * Adjustable by this contract's owner through use of the `setThreshold` function.\n     * @dev We note that there is an edge case -- when the threshold is adjusted downward, if a state root already has enough votes to meet the *new* threshold,\n     * the state root must still receive one additional vote from an oracle signer to be confirmed. This behavior is intended, to minimize unexpected root confirmations.\n     */\n    function threshold() external view returns(uint256);\n\n    /**\n     * @notice Owner-only function used to modify the value of the `threshold` variable.\n     * @param _threshold Desired new value for the `threshold` variable. Function will revert if this is set to zero.\n     */\n    function setThreshold(uint256 _threshold) external;\n\n    /**\n     * @notice Owner-only function used to add a signer to the set of oracle signers.\n     * @param _oracleSigners Array of address to be added to the set.\n     * @dev Function will have no effect on the i-th input address if `_oracleSigners[i]`is already in the set of oracle signers.\n     */\n    function addOracleSigners(address[] memory _oracleSigners) external;\n\n    /**\n     * @notice Owner-only function used to remove a signer from the set of oracle signers.\n     * @param _oracleSigners Array of address to be removed from the set.\n     * @dev Function will have no effect on the i-th input address if `_oracleSigners[i]`is already not in the set of oracle signers.\n     */\n    function removeOracleSigners(address[] memory _oracleSigners) external;\n\n    /**\n     * @notice Called by a member of the set of oracle signers to assert that the Beacon Chain state root is `stateRoot` at `blockNumber`.\n     * @dev The state root will be finalized once the total number of votes *for this exact state root at this exact blockNumber* meets the `threshold` value.\n     * @param blockNumber The Beacon Chain blockNumber of interest.\n     * @param stateRoot The Beacon Chain state root that the caller asserts was the correct root, at the specified `blockNumber`.\n     */\n    function voteForBeaconChainStateRoot(uint64 blockNumber, bytes32 stateRoot) external;\n}"
    },
    "contracts/EigenLayer/interfaces/IBLSPublicKeyCompendium.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"../libraries/BN254.sol\";\n\n/**\n * @title Minimal interface for the `BLSPublicKeyCompendium` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IBLSPublicKeyCompendium {\n    /**\n     * @notice mapping from operator address to pubkey hash.\n     * Returns *zero* if the `operator` has never registered, and otherwise returns the hash of the public key of the operator.\n     */\n    function operatorToPubkeyHash(address operator) external view returns (bytes32);\n\n    /**\n     * @notice mapping from pubkey hash to operator address.\n     * Returns *zero* if no operator has ever registered the public key corresponding to `pubkeyHash`,\n     * and otherwise returns the (unique) registered operator who owns the BLS public key that is the preimage of `pubkeyHash`.\n     */\n    function pubkeyHashToOperator(bytes32 pubkeyHash) external view returns (address);\n\n    /**\n     * @notice Called by an operator to register themselves as the owner of a BLS public key and reveal their G1 and G2 public key.\n     * @param s is the field element of the operator's Schnorr signature\n     * @param rPoint is the group element of the operator's Schnorr signature\n     * @param pubkeyG1 is the the G1 pubkey of the operator\n     * @param pubkeyG2 is the G2 with the same private key as the pubkeyG1\n     */\n    function registerBLSPublicKey(uint256 s, BN254.G1Point memory rPoint, BN254.G1Point memory pubkeyG1, BN254.G2Point memory pubkeyG2) external;\n}\n"
    },
    "contracts/EigenLayer/interfaces/IBLSRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IQuorumRegistry.sol\";\n\n/**\n * @title Minimal interface extension to `IQuorumRegistry`.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Adds BLS-specific functions to the base interface.\n */\ninterface IBLSRegistry is IQuorumRegistry {\n    /// @notice Data structure used to track the history of the Aggregate Public Key of all operators\n    struct ApkUpdate {\n        // keccak256(apk_x0, apk_x1, apk_y0, apk_y1)\n        bytes32 apkHash;\n        // block number at which the update occurred\n        uint32 blockNumber;\n    }\n\n    /**\n     * @notice get hash of a historical aggregated public key corresponding to a given index;\n     * called by checkSignatures in BLSSignatureChecker.sol.\n     */\n    function getCorrectApkHash(uint256 index, uint32 blockNumber) external returns (bytes32);\n\n    /// @notice returns the `ApkUpdate` struct at `index` in the list of APK updates\n    function apkUpdates(uint256 index) external view returns (ApkUpdate memory);\n\n    /// @notice returns the APK hash that resulted from the `index`th APK update\n    function apkHashes(uint256 index) external view returns (bytes32);\n\n    /// @notice returns the block number at which the `index`th APK update occurred\n    function apkUpdateBlockNumbers(uint256 index) external view returns (uint32);\n\n    function operatorWhitelister() external view returns(address);\n\n    function operatorWhitelistEnabled() external view returns(bool);\n\n    function whitelisted(address) external view returns(bool);\n\n    function setOperatorWhitelistStatus(bool _operatorWhitelistEnabled) external;\n\n    function addToOperatorWhitelist(address[] calldata) external;\n\n    function removeFromWhitelist(address[] calldata operators) external;\n}"
    },
    "contracts/EigenLayer/interfaces/IDelayedService.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Interface for a middleware / service that may look at past stake amounts.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Specifically, this interface is designed for services that consult stake amounts up to `BLOCK_STALE_MEASURE`\n * blocks in the past. This may be necessary due to, e.g., network processing & communication delays, or to avoid race conditions\n * that could be present with coordinating aggregate operator signatures while service operators are registering & de-registering.\n * @dev To clarify edge cases, the middleware can look `BLOCK_STALE_MEASURE` blocks into the past, i.e. it may trust stakes from the interval\n * [block.number - BLOCK_STALE_MEASURE, block.number] (specifically, *inclusive* of the block that is `BLOCK_STALE_MEASURE` before the current one)\n */\ninterface IDelayedService {\n    /// @notice The maximum amount of blocks in the past that the service will consider stake amounts to still be 'valid'.\n    function BLOCK_STALE_MEASURE() external view returns(uint32);    \n}\n"
    },
    "contracts/EigenLayer/interfaces/IDelayedWithdrawalRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\ninterface IDelayedWithdrawalRouter {\n    // struct used to pack data into a single storage slot\n    struct DelayedWithdrawal {\n        uint224 amount;\n        uint32 blockCreated;\n    }\n\n    // struct used to store a single users delayedWithdrawal data\n    struct UserDelayedWithdrawals {\n        uint256 delayedWithdrawalsCompleted;\n        DelayedWithdrawal[] delayedWithdrawals;\n    }\n\n    /** \n     * @notice Creates an delayed withdrawal for `msg.value` to the `recipient`.\n     * @dev Only callable by the `podOwner`'s EigenPod contract.\n     */\n    function createDelayedWithdrawal(address podOwner, address recipient) external payable;\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the `recipient` that have passed the `withdrawalDelayBlocks` period.\n     * @param recipient The address to claim delayedWithdrawals for.\n     * @param maxNumberOfWithdrawalsToClaim Used to limit the maximum number of withdrawals to loop through claiming.\n     */\n    function claimDelayedWithdrawals(address recipient, uint256 maxNumberOfWithdrawalsToClaim) external;\n\n    /**\n     * @notice Called in order to withdraw delayed withdrawals made to the caller that have passed the `withdrawalDelayBlocks` period.\n     * @param maxNumberOfWithdrawalsToClaim Used to limit the maximum number of withdrawals to loop through claiming.\n     */\n    function claimDelayedWithdrawals(uint256 maxNumberOfWithdrawalsToClaim) external;\n\n    /// @notice Owner-only function for modifying the value of the `withdrawalDelayBlocks` variable.\n    function setWithdrawalDelayBlocks(uint256 newValue) external;\n\n    /// @notice Getter function for the mapping `_userWithdrawals`\n    function userWithdrawals(address user) external view returns (UserDelayedWithdrawals memory);\n\n    /// @notice Getter function to get all delayedWithdrawals of the `user`\n    function getUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory);\n\n    /// @notice Getter function to get all delayedWithdrawals that are currently claimable by the `user`\n    function getClaimableUserDelayedWithdrawals(address user) external view returns (DelayedWithdrawal[] memory);\n    \n    /// @notice Getter function for fetching the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array\n    function userDelayedWithdrawalByIndex(address user, uint256 index) external view returns (DelayedWithdrawal memory);\n\n    /// @notice Getter function for fetching the length of the delayedWithdrawals array of a specific user\n    function userWithdrawalsLength(address user) external view returns (uint256);\n\n    /// @notice Convenience function for checking whether or not the delayedWithdrawal at the `index`th entry from the `_userWithdrawals[user].delayedWithdrawals` array is currently claimable\n    function canClaimDelayedWithdrawal(address user, uint256 index) external view returns (bool);\n\n    /**\n     * @notice Delay enforced by this contract for completing any delayedWithdrawal. Measured in blocks, and adjustable by this contract's owner,\n     * up to a maximum of `MAX_WITHDRAWAL_DELAY_BLOCKS`. Minimum value is 0 (i.e. no delay enforced).\n     */\n    function withdrawalDelayBlocks() external view returns (uint256);\n}"
    },
    "contracts/EigenLayer/interfaces/IDelegationManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IDelegationTerms.sol\";\n\n/**\n * @title The interface for the primary delegation contract for EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice  This is the contract for delegation in EigenLayer. The main functionalities of this contract are\n * - enabling anyone to register as an operator in EigenLayer\n * - allowing new operators to provide a DelegationTerms-type contract, which may mediate their interactions with stakers who delegate to them\n * - enabling any staker to delegate its stake to the operator of its choice\n * - enabling a staker to undelegate its assets from an operator (performed as part of the withdrawal process, initiated through the StrategyManager)\n */\ninterface IDelegationManager {\n\n    /**\n     * @notice This will be called by an operator to register itself as an operator that stakers can choose to delegate to.\n     * @param dt is the `DelegationTerms` contract that the operator has for those who delegate to them.\n     * @dev An operator can set `dt` equal to their own address (or another EOA address), in the event that they want to split payments\n     * in a more 'trustful' manner.\n     * @dev In the present design, once set, there is no way for an operator to ever modify the address of their DelegationTerms contract.\n     */\n    function registerAsOperator(IDelegationTerms dt) external;\n\n    /**\n     *  @notice This will be called by a staker to delegate its assets to some operator.\n     *  @param operator is the operator to whom staker (msg.sender) is delegating its assets\n     */\n    function delegateTo(address operator) external;\n\n    /**\n     * @notice Delegates from `staker` to `operator`.\n     * @dev requires that:\n     * 1) if `staker` is an EOA, then `signature` is valid ECDSA signature from `staker`, indicating their intention for this action\n     * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n     */\n    function delegateToBySignature(address staker, address operator, uint256 expiry, bytes memory signature) external;\n\n    /**\n     * @notice Undelegates `staker` from the operator who they are delegated to.\n     * @notice Callable only by the StrategyManager\n     * @dev Should only ever be called in the event that the `staker` has no active deposits in EigenLayer.\n     */\n    function undelegate(address staker) external;\n\n    /// @notice returns the address of the operator that `staker` is delegated to.\n    function delegatedTo(address staker) external view returns (address);\n\n    /// @notice returns the DelegationTerms of the `operator`, which may mediate their interactions with stakers who delegate to them.\n    function delegationTerms(address operator) external view returns (IDelegationTerms);\n\n    /// @notice returns the total number of shares in `strategy` that are delegated to `operator`.\n    function operatorShares(address operator, IStrategy strategy) external view returns (uint256);\n\n    /**\n     * @notice Increases the `staker`'s delegated shares in `strategy` by `shares, typically called when the staker has further deposits into EigenLayer\n     * @dev Callable only by the StrategyManager\n     */\n    function increaseDelegatedShares(address staker, IStrategy strategy, uint256 shares) external;\n\n    /**\n     * @notice Decreases the `staker`'s delegated shares in each entry of `strategies` by its respective `shares[i]`, typically called when the staker withdraws from EigenLayer\n     * @dev Callable only by the StrategyManager\n     */\n    function decreaseDelegatedShares(\n        address staker,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares\n    ) external;\n\n    /// @notice Returns 'true' if `staker` *is* actively delegated, and 'false' otherwise.\n    function isDelegated(address staker) external view returns (bool);\n\n    /// @notice Returns 'true' if `staker` is *not* actively delegated, and 'false' otherwise.\n    function isNotDelegated(address staker) external view returns (bool);\n\n    /// @notice Returns if an operator can be delegated to, i.e. it has called `registerAsOperator`.\n    function isOperator(address operator) external view returns (bool);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IDelegationTerms.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IStrategy.sol\";\n\n/**\n * @title Abstract interface for a contract that helps structure the delegation relationship.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The gas budget provided to this contract in calls from EigenLayer contracts is limited.\n */\ninterface IDelegationTerms {\n    function payForService(IERC20 token, uint256 amount) external payable;\n\n    function onDelegationWithdrawn(\n        address delegator,\n        IStrategy[] memory stakerStrategyList,\n        uint256[] memory stakerShares\n    ) external returns(bytes memory);\n\n    function onDelegationReceived(\n        address delegator,\n        IStrategy[] memory stakerStrategyList,\n        uint256[] memory stakerShares\n    ) external returns(bytes memory);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IEigenPod.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"../libraries/BeaconChainProofs.sol\";\nimport \"./IEigenPodManager.sol\";\nimport \"./IBeaconChainOracle.sol\";\n\n/**\n * @title The implementation contract used for restaking beacon chain ETH on EigenLayer \n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice The main functionalities are:\n * - creating new ETH validators with their withdrawal credentials pointed to this contract\n * - proving from beacon chain state roots that withdrawal credentials are pointed to this contract\n * - proving from beacon chain state roots the balances of ETH validators with their withdrawal credentials\n *   pointed to this contract\n * - updating aggregate balances in the EigenPodManager\n * - withdrawing eth when withdrawals are initiated\n * @dev Note that all beacon chain balances are stored as gwei within the beacon chain datastructures. We choose\n *   to account balances in terms of gwei in the EigenPod contract and convert to wei when making calls to other contracts\n */\ninterface IEigenPod {\n    enum VALIDATOR_STATUS {\n        INACTIVE, // doesnt exist\n        ACTIVE, // staked on ethpos and withdrawal credentials are pointed to the EigenPod\n        OVERCOMMITTED, // proven to be overcommitted to EigenLayer\n        WITHDRAWN // withdrawn from the Beacon Chain\n    }\n\n    // this struct keeps track of PartialWithdrawalClaims\n    struct PartialWithdrawalClaim {\n        PARTIAL_WITHDRAWAL_CLAIM_STATUS status;\n        // block at which the PartialWithdrawalClaim was created\n        uint32 creationBlockNumber;\n        // last block (inclusive) in which the PartialWithdrawalClaim can be fraudproofed\n        uint32 fraudproofPeriodEndBlockNumber;\n        // amount of ETH -- in Gwei -- to be withdrawn until completion of this claim\n        uint64 partialWithdrawalAmountGwei;\n    }\n\n    enum PARTIAL_WITHDRAWAL_CLAIM_STATUS {\n        REDEEMED,\n        PENDING,\n        FAILED\n    }\n\n    /// @notice The amount of eth, in gwei, that is restaked per validator\n    function REQUIRED_BALANCE_GWEI() external view returns(uint64);\n\n    /// @notice The amount of eth, in wei, that is restaked per validator\n    function REQUIRED_BALANCE_WEI() external view returns(uint256);\n\n    /// @notice this is a mapping of validator indices to a Validator struct containing pertinent info about the validator\n    function validatorStatus(uint40 validatorIndex) external view returns(VALIDATOR_STATUS);\n\n    /// @notice the amount of execution layer ETH in this contract that is staked in EigenLayer (i.e. withdrawn from beaconchain but not EigenLayer), \n    function restakedExecutionLayerGwei() external view returns(uint64);\n\n    /// @notice Used to initialize the pointers to contracts crucial to the pod's functionality, in beacon proxy construction from EigenPodManager\n    function initialize(address owner) external;\n\n    /// @notice Called by EigenPodManager when the owner wants to create another ETH validator.\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n\n    /**\n     * @notice Transfers `amountWei` in ether from this contract to the specified `recipient` address\n     * @notice Called by EigenPodManager to withdrawBeaconChainETH that has been added to the EigenPod's balance due to a withdrawal from the beacon chain.\n     * @dev Called during withdrawal or slashing.\n     * @dev Note that this function is marked as non-reentrant to prevent the recipient calling back into it\n     */\n    function withdrawRestakedBeaconChainETH(address recipient, uint256 amount) external;\n\n    /// @notice The single EigenPodManager for EigenLayer\n    function eigenPodManager() external view returns (IEigenPodManager);\n\n    /// @notice The owner of this EigenPod\n    function podOwner() external view returns (address);\n\n    /// @notice an indicator of whether or not the podOwner has ever \"fully restaked\" by successfully calling `verifyCorrectWithdrawalCredentials`.\n    function hasRestaked() external view returns (bool);\n\n    /// @notice block number of the most recent withdrawal\n    function mostRecentWithdrawalBlockNumber() external view returns (uint64);\n\n\n    ///@notice mapping that tracks proven partial withdrawals\n    function provenPartialWithdrawal(uint40 validatorIndex, uint64 slot) external view returns (bool);\n\n    /**\n     * @notice This function verifies that the withdrawal credentials of the podOwner are pointed to\n     * this contract. It also verifies the current (not effective) balance  of the validator.  It verifies the provided proof of the ETH validator against the beacon chain state\n     * root, marks the validator as 'active' in EigenLayer, and credits the restaked ETH in Eigenlayer.\n     * @param oracleBlockNumber is the Beacon Chain blockNumber whose state root the `proof` will be proven against.\n     * @param validatorIndex is the index of the validator being proven, refer to consensus specs \n     * @param proofs is the bytes that prove the ETH validator's balance and withdrawal credentials against a beacon chain state root\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs \n     * for details: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyWithdrawalCredentialsAndBalance(\n        uint64 oracleBlockNumber,\n        uint40 validatorIndex,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs memory proofs,\n        bytes32[] calldata validatorFields\n    ) external;\n    \n    /**\n     * @notice This function records an overcommitment of stake to EigenLayer on behalf of a certain ETH validator.\n     *         If successful, the overcommitted balance is penalized (available for withdrawal whenever the pod's balance allows).\n     *         The ETH validator's shares in the enshrined beaconChainETH strategy are also removed from the StrategyManager and undelegated.\n     * @param oracleBlockNumber The oracleBlockNumber whose state root the `proof` will be proven against.\n     *        Must be within `VERIFY_OVERCOMMITTED_WINDOW_BLOCKS` of the current block.\n     * @param validatorIndex is the index of the validator being proven, refer to consensus specs \n     * @param proofs is the proof of the validator's balance and validatorFields in the balance tree and the balanceRoot to prove for\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy for the pod owner for the callback to \n     *                                    the StrategyManager in case it must be removed from the list of the podOwners strategies\n     * @param validatorFields are the fields of the \"Validator Container\", refer to consensus specs\n     * @dev For more details on the Beacon Chain spec, see: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#validator\n     */\n    function verifyOvercommittedStake(\n        uint40 validatorIndex,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs calldata proofs,\n        bytes32[] calldata validatorFields,\n        uint256 beaconChainETHStrategyIndex,\n        uint64 oracleBlockNumber\n    ) external;\n\n    /**\n     * @notice This function records a full withdrawal on behalf of one of the Ethereum validators for this EigenPod\n     * @param withdrawalProofs is the information needed to check the veracity of the block number and withdrawal being proven\n     * @param validatorFieldsProof is the proof of the validator's fields in the validator tree\n     * @param withdrawalFields are the fields of the withdrawal being proven\n     * @param validatorFields are the fields of the validator being proven\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy for the pod owner for the callback to \n     *        the EigenPodManager to the StrategyManager in case it must be removed from the podOwner's list of strategies\n     */\n    function verifyAndProcessWithdrawal(\n        BeaconChainProofs.WithdrawalProofs calldata withdrawalProofs, \n        bytes calldata validatorFieldsProof,\n        bytes32[] calldata validatorFields,\n        bytes32[] calldata withdrawalFields,\n        uint256 beaconChainETHStrategyIndex,\n        uint64 oracleBlockNumber\n    ) external;\n\n    /// @notice Called by the pod owner to withdraw the balance of the pod when `hasRestaked` is set to false\n    function withdrawBeforeRestaking() external;\n}"
    },
    "contracts/EigenLayer/interfaces/IEigenPodManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IStrategyManager.sol\";\nimport \"./IEigenPod.sol\";\nimport \"./IBeaconChainOracle.sol\";\nimport \"./IPausable.sol\";\n\n/**\n * @title Interface for factory that creates and manages solo staking pods that have their withdrawal credentials pointed to EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\n\ninterface IEigenPodManager is IPausable {\n    /**\n     * @notice Creates an EigenPod for the sender.\n     * @dev Function will revert if the `msg.sender` already has an EigenPod.\n     */\n    function createPod() external;\n\n    /**\n     * @notice Stakes for a new beacon chain validator on the sender's EigenPod. \n     * Also creates an EigenPod for the sender if they don't have one already.\n     * @param pubkey The 48 bytes public key of the beacon chain validator.\n     * @param signature The validator's signature of the deposit data.\n     * @param depositDataRoot The root/hash of the deposit data for the validator's deposit.\n     */\n    function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n\n    /**\n     * @notice Deposits/Restakes beacon chain ETH in EigenLayer on behalf of the owner of an EigenPod.\n     * @param podOwner The owner of the pod whose balance must be deposited.\n     * @param amount The amount of ETH to 'deposit' (i.e. be credited to the podOwner).\n     * @dev Callable only by the podOwner's EigenPod contract.\n     */\n    function restakeBeaconChainETH(address podOwner, uint256 amount) external;\n\n    /**\n     * @notice Removes beacon chain ETH from EigenLayer on behalf of the owner of an EigenPod, when the\n     *         balance of a validator is lower than how much stake they have committed to EigenLayer\n     * @param podOwner The owner of the pod whose balance must be removed.\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy for the pod owner for the callback to \n     *                                    the StrategyManager in case it must be removed from the list of the podOwner's strategies\n     * @param amount The amount of ETH to remove.\n     * @dev Callable only by the podOwner's EigenPod contract.\n     */\n    function recordOvercommittedBeaconChainETH(address podOwner, uint256 beaconChainETHStrategyIndex, uint256 amount) external;\n    \n    /**\n     * @notice Withdraws ETH from an EigenPod. The ETH must have first been withdrawn from the beacon chain.\n     * @param podOwner The owner of the pod whose balance must be withdrawn.\n     * @param recipient The recipient of the withdrawn ETH.\n     * @param amount The amount of ETH to withdraw.\n     * @dev Callable only by the StrategyManager contract.\n     */\n    function withdrawRestakedBeaconChainETH(address podOwner, address recipient, uint256 amount) external;\n\n    /**\n     * @notice Updates the oracle contract that provides the beacon chain state root\n     * @param newBeaconChainOracle is the new oracle contract being pointed to\n     * @dev Callable only by the owner of this contract (i.e. governance)\n     */\n    function updateBeaconChainOracle(IBeaconChainOracle newBeaconChainOracle) external;\n\n    /// @notice Returns the address of the `podOwner`'s EigenPod if it has been deployed.\n    function ownerToPod(address podOwner) external view returns(IEigenPod);\n\n    /// @notice Returns the address of the `podOwner`'s EigenPod (whether it is deployed yet or not).\n    function getPod(address podOwner) external view returns(IEigenPod);\n\n    /// @notice Oracle contract that provides updates to the beacon chain's state\n    function beaconChainOracle() external view returns(IBeaconChainOracle);    \n\n    /// @notice Returns the Beacon Chain state root at `blockNumber`. Reverts if the Beacon Chain state root at `blockNumber` has not yet been finalized.\n    function getBeaconChainStateRoot(uint64 blockNumber) external view returns(bytes32);\n\n    /// @notice EigenLayer's StrategyManager contract\n    function strategyManager() external view returns(IStrategyManager);\n\n    /// @notice EigenLayer's Slasher contract\n    function slasher() external view returns(ISlasher);\n\n    function hasPod(address podOwner) external view returns (bool);\n}"
    },
    "contracts/EigenLayer/interfaces/IETHPOSDeposit.sol": {
      "content": "// ┏━━━┓━┏┓━┏┓━━┏━━━┓━━┏━━━┓━━━━┏━━━┓━━━━━━━━━━━━━━━━━━━┏┓━━━━━┏━━━┓━━━━━━━━━┏┓━━━━━━━━━━━━━━┏┓━\n// ┃┏━━┛┏┛┗┓┃┃━━┃┏━┓┃━━┃┏━┓┃━━━━┗┓┏┓┃━━━━━━━━━━━━━━━━━━┏┛┗┓━━━━┃┏━┓┃━━━━━━━━┏┛┗┓━━━━━━━━━━━━┏┛┗┓\n// ┃┗━━┓┗┓┏┛┃┗━┓┗┛┏┛┃━━┃┃━┃┃━━━━━┃┃┃┃┏━━┓┏━━┓┏━━┓┏━━┓┏┓┗┓┏┛━━━━┃┃━┗┛┏━━┓┏━┓━┗┓┏┛┏━┓┏━━┓━┏━━┓┗┓┏┛\n// ┃┏━━┛━┃┃━┃┏┓┃┏━┛┏┛━━┃┃━┃┃━━━━━┃┃┃┃┃┏┓┃┃┏┓┃┃┏┓┃┃━━┫┣┫━┃┃━━━━━┃┃━┏┓┃┏┓┃┃┏┓┓━┃┃━┃┏┛┗━┓┃━┃┏━┛━┃┃━\n// ┃┗━━┓━┃┗┓┃┃┃┃┃┃┗━┓┏┓┃┗━┛┃━━━━┏┛┗┛┃┃┃━┫┃┗┛┃┃┗┛┃┣━━┃┃┃━┃┗┓━━━━┃┗━┛┃┃┗┛┃┃┃┃┃━┃┗┓┃┃━┃┗┛┗┓┃┗━┓━┃┗┓\n// ┗━━━┛━┗━┛┗┛┗┛┗━━━┛┗┛┗━━━┛━━━━┗━━━┛┗━━┛┃┏━┛┗━━┛┗━━┛┗┛━┗━┛━━━━┗━━━┛┗━━┛┗┛┗┛━┗━┛┗┛━┗━━━┛┗━━┛━┗━┛\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┃┃━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┗┛━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\n// SPDX-License-Identifier: CC0-1.0\n\npragma solidity =0.8.19;\n\n// This interface is designed to be compatible with the Vyper version.\n/// @notice This is the Ethereum 2.0 deposit contract interface.\n/// For more information see the Phase 0 specification under https://github.com/ethereum/eth2.0-specs\ninterface IETHPOSDeposit {\n    /// @notice A processed deposit event.\n    event DepositEvent(bytes pubkey, bytes withdrawal_credentials, bytes amount, bytes signature, bytes index);\n\n    /// @notice Submit a Phase 0 DepositData object.\n    /// @param pubkey A BLS12-381 public key.\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\n    /// @param signature A BLS12-381 signature.\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\n    /// Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    /// @notice Query the current deposit root hash.\n    /// @return The deposit root hash.\n    function get_deposit_root() external view returns (bytes32);\n\n    /// @notice Query the current deposit count.\n    /// @return The deposit count encoded as a little endian 64-bit number.\n    function get_deposit_count() external view returns (bytes memory);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"../interfaces/IPauserRegistry.sol\";\n\n/**\n * @title Adds pausability to a contract, with pausing & unpausing controlled by the `pauser` and `unpauser` of a PauserRegistry contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Contracts that inherit from this contract may define their own `pause` and `unpause` (and/or related) functions.\n * These functions should be permissioned as \"onlyPauser\" which defers to a `PauserRegistry` for determining access control.\n * @dev Pausability is implemented using a uint256, which allows up to 256 different single bit-flags; each bit can potentially pause different functionality.\n * Inspiration for this was taken from the NearBridge design here https://etherscan.io/address/0x3FEFc5A4B1c02f21cBc8D3613643ba0635b9a873#code.\n * For the `pause` and `unpause` functions we've implemented, if you pause, you can only flip (any number of) switches to on/1 (aka \"paused\"), and if you unpause,\n * you can only flip (any number of) switches to off/0 (aka \"paused\").\n * If you want a pauseXYZ function that just flips a single bit / \"pausing flag\", it will:\n * 1) 'bit-wise and' (aka `&`) a flag with the current paused state (as a uint256)\n * 2) update the paused state to this new value\n * @dev We note as well that we have chosen to identify flags by their *bit index* as opposed to their numerical value, so, e.g. defining `DEPOSITS_PAUSED = 3`\n * indicates specifically that if the *third bit* of `_paused` is flipped -- i.e. it is a '1' -- then deposits should be paused\n */\n\ninterface IPausable {\n    /// @notice Address of the `PauserRegistry` contract that this contract defers to for determining access control (for pausing).\n    function pauserRegistry() external view returns (IPauserRegistry); \n\n    /**\n     * @notice This function is used to pause an EigenLayer contract's functionality.\n     * It is permissioned to the `pauser` address, which is expected to be a low threshold multisig.\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\n     * @dev This function can only pause functionality, and thus cannot 'unflip' any bit in `_paused` from 1 to 0.\n     */\n    function pause(uint256 newPausedStatus) external;\n\n    /**\n     * @notice Alias for `pause(type(uint256).max)`.\n     */\n    function pauseAll() external;\n\n    /**\n     * @notice This function is used to unpause an EigenLayer contract's functionality.\n     * It is permissioned to the `unpauser` address, which is expected to be a high threshold multisig or governance contract.\n     * @param newPausedStatus represents the new value for `_paused` to take, which means it may flip several bits at once.\n     * @dev This function can only unpause functionality, and thus cannot 'flip' any bit in `_paused` from 0 to 1.\n     */\n    function unpause(uint256 newPausedStatus) external;\n\n    /// @notice Returns the current paused status as a uint256.\n    function paused() external view returns (uint256);\n\n    /// @notice Returns 'true' if the `indexed`th bit of `_paused` is 1, and 'false' otherwise\n    function paused(uint8 index) external view returns (bool);\n\n    /// @notice Allows the unpauser to set a new pauser registry\n    function setPauserRegistry(IPauserRegistry newPauserRegistry) external;\n}\n"
    },
    "contracts/EigenLayer/interfaces/IPauserRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Interface for the `PauserRegistry` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IPauserRegistry {\n    /// @notice Mapping of addresses to whether they hold the pauser role.\n    function isPauser(address pauser) external view returns (bool);\n\n    /// @notice Unique address that holds the unpauser role. Capable of changing *both* the pauser and unpauser addresses.\n    function unpauser() external view returns (address);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Interface for a `PaymentManager` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IPaymentManager {\n    enum DissectionType {\n        INVALID,\n        FIRST_HALF,\n        SECOND_HALF\n    }\n    enum PaymentStatus {\n        REDEEMED,\n        COMMITTED,\n        CHALLENGED\n    }\n    enum ChallengeStatus {\n        RESOLVED,\n        OPERATOR_TURN,\n        CHALLENGER_TURN,\n        OPERATOR_TURN_ONE_STEP,\n        CHALLENGER_TURN_ONE_STEP\n    }\n\n    /**\n     * @notice used for storing information on the most recent payment made to the operator\n     */\n    struct Payment {\n        // taskNumber starting from which payment is being claimed\n        uint32 fromTaskNumber;\n        // taskNumber until which payment is being claimed (exclusive)\n        uint32 toTaskNumber;\n        // recording when the payment will optimistically be confirmed; used for fraudproof period\n        uint32 confirmAt;\n        // payment for range [fromTaskNumber, toTaskNumber)\n        /// @dev max 1.3e36, keep in mind for token decimals\n        uint96 amount;\n        /**\n         * @notice The possible statuses are:\n         * - 0: REDEEMED,\n         * - 1: COMMITTED,\n         * - 2: CHALLENGED\n         */\n        PaymentStatus status;\n        uint256 challengeAmount; //account for if challengeAmount changed\n    }\n\n    /**\n     * @notice used for storing information on the payment challenge as part of the interactive process\n     */\n    struct PaymentChallenge {\n        // operator whose payment claim is being challenged,\n        address operator;\n        // the entity challenging with the fraudproof\n        address challenger;\n        // address of the service manager contract\n        address serviceManager;\n        // the TaskNumber from which payment has been computed\n        uint32 fromTaskNumber;\n        // the TaskNumber until which payment has been computed to\n        uint32 toTaskNumber;\n        // reward amount the challenger claims is for the first half of tasks\n        uint96 amount1;\n        // reward amount the challenger claims is for the second half of tasks\n        uint96 amount2;\n        // used for recording the time when challenge was created\n        uint32 settleAt; // when committed, used for fraudproof period\n        // indicates the status of the challenge\n        /**\n         * @notice The possible statuses are:\n         * - 0: RESOLVED,\n         * - 1: operator turn (dissection),\n         * - 2: challenger turn (dissection),\n         * - 3: operator turn (one step),\n         * - 4: challenger turn (one step)\n         */\n        ChallengeStatus status;\n    }\n\n    struct TotalStakes {\n        uint256 signedStakeFirstQuorum;\n        uint256 signedStakeSecondQuorum;\n    }\n\n    /**\n     * @notice deposit one-time fees by the `msg.sender` with this contract to pay for future tasks of this middleware\n     * @param depositFor could be the `msg.sender` themselves, or a different address for whom `msg.sender` is depositing these future fees\n     * @param amount is amount of futures fees being deposited\n     */\n    function depositFutureFees(address depositFor, uint256 amount) external;\n\n    /// @notice Allows the `allowed` address to spend up to `amount` of the `msg.sender`'s funds that have been deposited in this contract\n    function setAllowance(address allowed, uint256 amount) external;\n\n    /// @notice Used for deducting the fees from the payer to the middleware\n    function takeFee(address initiator, address payer, uint256 feeAmount) external;\n\n    /**\n     * @notice Modifies the `paymentChallengeAmount` amount.\n     * @param _paymentChallengeAmount The new value for `paymentChallengeAmount` to take.\n     */\n    function setPaymentChallengeAmount(uint256 _paymentChallengeAmount) external;\n\n    /**\n     * @notice This is used by an operator to make a claim on the amount that they deserve for their service from their last payment until `toTaskNumber`\n     * @dev Once this payment is recorded, a fraud proof period commences during which a challenger can dispute the proposed payment.\n     */\n    function commitPayment(uint32 toTaskNumber, uint96 amount) external;\n\n    /**\n     * @notice Called by an operator to redeem a payment that they previously 'committed' to by calling `commitPayment`.\n     * @dev This function can only be called after the challenge window for the payment claim has completed.\n     */\n    function redeemPayment() external;\n\n    /**\n     * @notice This function is called by a fraud prover to challenge a payment, initiating an interactive-type fraudproof.\n     * @param operator is the operator against whose payment claim the fraudproof is being made\n     * @param amount1 is the reward amount the challenger in that round claims is for the first half of tasks\n     * @param amount2 is the reward amount the challenger in that round claims is for the second half of tasks\n     *\n     */\n    function initPaymentChallenge(address operator, uint96 amount1, uint96 amount2) external;\n\n    /**\n     * @notice Perform a single bisection step in an existing interactive payment challenge.\n     * @param operator The middleware operator who was challenged (used to look up challenge details)\n     * @param secondHalf If true, then the caller wishes to challenge the amount claimed as payment in the *second half* of the\n     * previous bisection step. If false then the *first half* is indicated instead.\n     * @param amount1 The amount that the caller asserts the operator is entitled to, for the first half *of the challenged half* of the previous bisection.\n     * @param amount2 The amount that the caller asserts the operator is entitled to, for the second half *of the challenged half* of the previous bisection.\n     */\n    function performChallengeBisectionStep(address operator, bool secondHalf, uint96 amount1, uint96 amount2)\n        external;\n\n    /// @notice resolve an existing PaymentChallenge for an operator\n    function resolveChallenge(address operator) external;\n\n    /**\n     * @notice Challenge window for submitting fraudproof in the case of an incorrect payment claim by a registered operator.\n     */\n    function paymentFraudproofInterval() external view returns (uint256);\n\n    /**\n     * @notice Specifies the payment that has to be made as a guarantee for fraudproof during payment challenges.\n     */\n    function paymentChallengeAmount() external view returns (uint256);\n\n    /// @notice the ERC20 token that will be used by the disperser to pay the service fees to middleware nodes.\n    function paymentToken() external view returns (IERC20);\n\n    /// @notice Token used for placing a guarantee on challenges & payment commits\n    function paymentChallengeToken() external view returns (IERC20);\n\n    /// @notice Returns the ChallengeStatus for the `operator`'s payment claim.\n    function getChallengeStatus(address operator) external view returns (ChallengeStatus);\n\n    /// @notice Returns the 'amount1' for the `operator`'s payment claim.\n    function getAmount1(address operator) external view returns (uint96);\n\n    /// @notice Returns the 'amount2' for the `operator`'s payment claim.\n    function getAmount2(address operator) external view returns (uint96);\n\n    /// @notice Returns the 'toTaskNumber' for the `operator`'s payment claim.\n    function getToTaskNumber(address operator) external view returns (uint48);\n\n    /// @notice Returns the 'fromTaskNumber' for the `operator`'s payment claim.\n    function getFromTaskNumber(address operator) external view returns (uint48);\n\n    /// @notice Returns the task number difference for the `operator`'s payment claim.\n    function getDiff(address operator) external view returns (uint48);\n\n    /// @notice Returns the active guarantee amount of the `operator` placed on their payment claim.\n    function getPaymentChallengeAmount(address) external view returns (uint256);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IQuorumRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IRegistry.sol\";\n\n/**\n * @title Interface for a `Registry`-type contract that uses either 1 or 2 quorums.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice This contract does not currently support n-quorums where n >= 3.\n * Note in particular the presence of only `firstQuorumStake` and `secondQuorumStake` in the `OperatorStake` struct.\n */\ninterface IQuorumRegistry is IRegistry {\n    // DATA STRUCTURES\n    enum Status\n    {\n        // default is inactive\n        INACTIVE,\n        ACTIVE\n    }\n\n    /**\n     * @notice  Data structure for storing info on operators to be used for:\n     * - sending data by the sequencer\n     * - payment and associated challenges\n     */\n    struct Operator {\n        // hash of pubkey of the operator\n        bytes32 pubkeyHash;\n        // start taskNumber from which the  operator has been registered\n        uint32 fromTaskNumber;\n        // indicates whether the operator is actively registered for serving the middleware or not\n        Status status;\n    }\n\n    // struct used to give definitive ordering to operators at each blockNumber\n    struct OperatorIndex {\n        // blockNumber number at which operator index changed\n        // note that the operator's index is different *for this block number*, i.e. the *new* index is *inclusive* of this value\n        uint32 toBlockNumber;\n        // index of the operator in array of operators, or the total number of operators if in the 'totalOperatorsHistory'\n        uint32 index;\n    }\n\n    /// @notice struct used to store the stakes of an individual operator or the sum of all operators' stakes, for storage\n    struct OperatorStake {\n        // the block number at which the stake amounts were updated and stored\n        uint32 updateBlockNumber;\n        // the block number at which the *next update* occurred.\n        /// @notice This entry has the value **0** until another update takes place.\n        uint32 nextUpdateBlockNumber;\n        // stake weight for the first quorum\n        uint96 firstQuorumStake;\n        // stake weight for the second quorum. Will always be zero in the event that only one quorum is used\n        uint96 secondQuorumStake;\n    }\n\n    function getLengthOfTotalStakeHistory() external view returns (uint256);\n\n    /**\n     * @notice Returns the `index`-th entry in the dynamic array of total stake, `totalStakeHistory`.\n     * @dev Function will revert in the event that `index` is out-of-bounds.\n     */\n    function getTotalStakeFromIndex(uint256 index) external view returns (OperatorStake memory);\n\n    /// @notice Returns the stored pubkeyHash for the specified `operator`.\n    function getOperatorPubkeyHash(address operator) external view returns (bytes32);\n\n    /// @notice Returns task number from when `operator` has been registered.\n    function getFromTaskNumberForOperator(address operator) external view returns (uint32);\n\n    /**\n     * @notice Returns the stake weight corresponding to `pubkeyHash`, at the\n     * `index`-th entry in the `pubkeyHashToStakeHistory[pubkeyHash]` array.\n     * @param pubkeyHash Hash of the public key of the operator of interest.\n     * @param index Array index for lookup, within the dynamic array `pubkeyHashToStakeHistory[pubkeyHash]`.\n     * @dev Function will revert if `index` is out-of-bounds.\n     */\n    function getStakeFromPubkeyHashAndIndex(bytes32 pubkeyHash, uint256 index)\n        external\n        view\n        returns (OperatorStake memory);\n\n    /**\n     * @notice Checks that the `operator` was active at the `blockNumber`, using the specified `stakeHistoryIndex` as proof.\n     * @param operator is the operator of interest\n     * @param blockNumber is the block number of interest\n     * @param stakeHistoryIndex specifies an index in `pubkeyHashToStakeHistory[pubkeyHash]`, where `pubkeyHash` is looked up\n     * in `registry[operator].pubkeyHash`\n     * @return 'true' if it is successfully proven that  the `operator` was active at the `blockNumber`, and 'false' otherwise\n     * @dev In order for this function to return 'true', the inputs must satisfy all of the following list:\n     * 1) `pubkeyHashToStakeHistory[pubkeyHash][index].updateBlockNumber <= blockNumber`\n     * 2) `pubkeyHashToStakeHistory[pubkeyHash][index].nextUpdateBlockNumber` must be either `0` (signifying no next update) or\n     * is must be strictly greater than `blockNumber`\n     * 3) `pubkeyHashToStakeHistory[pubkeyHash][index].firstQuorumStake > 0`\n     * or `pubkeyHashToStakeHistory[pubkeyHash][index].secondQuorumStake > 0`, i.e. the operator had nonzero stake\n     * @dev Note that a return value of 'false' does not guarantee that the `operator` was inactive at `blockNumber`, since a\n     * bad `stakeHistoryIndex` can be supplied in order to obtain a response of 'false'.\n     */\n    function checkOperatorActiveAtBlockNumber(\n        address operator,\n        uint256 blockNumber,\n        uint256 stakeHistoryIndex\n        ) external view returns (bool);\n\n    /**\n     * @notice Checks that the `operator` was inactive at the `blockNumber`, using the specified `stakeHistoryIndex` as proof.\n     * @param operator is the operator of interest\n     * @param blockNumber is the block number of interest\n     * @param stakeHistoryIndex specifies an index in `pubkeyHashToStakeHistory[pubkeyHash]`, where `pubkeyHash` is looked up\n     * in `registry[operator].pubkeyHash`\n     * @return 'true' if it is successfully proven that  the `operator` was inactive at the `blockNumber`, and 'false' otherwise\n     * @dev In order for this function to return 'true', the inputs must satisfy all of the following list:\n     * 1) `pubkeyHashToStakeHistory[pubkeyHash][index].updateBlockNumber <= blockNumber`\n     * 2) `pubkeyHashToStakeHistory[pubkeyHash][index].nextUpdateBlockNumber` must be either `0` (signifying no next update) or\n     * is must be strictly greater than `blockNumber`\n     * 3) `pubkeyHashToStakeHistory[pubkeyHash][index].firstQuorumStake > 0`\n     * or `pubkeyHashToStakeHistory[pubkeyHash][index].secondQuorumStake > 0`, i.e. the operator had nonzero stake\n     * @dev Note that a return value of 'false' does not guarantee that the `operator` was active at `blockNumber`, since a\n     * bad `stakeHistoryIndex` can be supplied in order to obtain a response of 'false'.\n     */\n    function checkOperatorInactiveAtBlockNumber(\n        address operator,\n        uint256 blockNumber,\n        uint256 stakeHistoryIndex\n        ) external view returns (bool);\n\n    /**\n     * @notice Looks up the `operator`'s index in the dynamic array `operatorList` at the specified `blockNumber`.\n     * @param index Used to specify the entry within the dynamic array `pubkeyHashToIndexHistory[pubkeyHash]` to \n     * read data from, where `pubkeyHash` is looked up from `operator`'s registration info\n     * @param blockNumber Is the desired block number at which we wish to query the operator's position in the `operatorList` array\n     * @dev Function will revert in the event that the specified `index` input does not identify the appropriate entry in the\n     * array `pubkeyHashToIndexHistory[pubkeyHash]` to pull the info from.\n    */\n    function getOperatorIndex(address operator, uint32 blockNumber, uint32 index) external view returns (uint32);\n\n    /**\n     * @notice Looks up the number of total operators at the specified `blockNumber`.\n     * @param index Input used to specify the entry within the dynamic array `totalOperatorsHistory` to read data from.\n     * @dev This function will revert if the provided `index` is out of bounds.\n    */\n    function getTotalOperators(uint32 blockNumber, uint32 index) external view returns (uint32);\n\n    /// @notice Returns the current number of operators of this service.\n    function numOperators() external view returns (uint32);\n\n    /**\n     * @notice Returns the most recent stake weights for the `operator`\n     * @dev Function returns weights of **0** in the event that the operator has no stake history\n     */\n    function operatorStakes(address operator) external view returns (uint96, uint96);\n\n    /// @notice Returns the stake amounts from the latest entry in `totalStakeHistory`.\n    function totalStake() external view returns (uint96, uint96);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Minimal interface for a `Registry`-type contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Functions related to the registration process itself have been intentionally excluded\n * because their function signatures may vary significantly.\n */\ninterface IRegistry {\n    /// @notice Returns 'true' if `operator` is registered as an active operator, and 'false' otherwise.\n    function isActiveOperator(address operator) external view returns (bool);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IServiceManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IDelegationManager.sol\";\n\n/**\n * @title Interface for a `ServiceManager`-type contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\ninterface IServiceManager {\n    /// @notice Returns the current 'taskNumber' for the middleware\n    function taskNumber() external view returns (uint32);\n\n    /// @notice Permissioned function that causes the ServiceManager to freeze the operator on EigenLayer, through a call to the Slasher contract\n    function freezeOperator(address operator) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording an initial stake update (on operator registration)\n    function recordFirstStakeUpdate(address operator, uint32 serveUntilBlock) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording a stake update\n    function recordStakeUpdate(address operator, uint32 updateBlock, uint32 serveUntilBlock, uint256 prevElement) external;\n\n    /// @notice Permissioned function to have the ServiceManager forward a call to the slasher, recording a final stake update (on operator deregistration)\n    function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntilBlock) external;\n\n    /// @notice Returns the latest block until which operators must serve.\n    function latestServeUntilBlock() external view returns (uint32);\n\n    function owner() external view returns (address);\n}"
    },
    "contracts/EigenLayer/interfaces/ISlasher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Interface for the primary 'slashing' contract for EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice See the `Slasher` contract itself for implementation details.\n */\ninterface ISlasher {\n    // struct used to store information about the current state of an operator's obligations to middlewares they are serving\n    struct MiddlewareTimes {\n        // The update block for the middleware whose most recent update was earliest, i.e. the 'stalest' update out of all middlewares the operator is serving\n        uint32 stalestUpdateBlock;\n        // The latest 'serveUntilBlock' from all of the middleware that the operator is serving\n        uint32 latestServeUntilBlock;\n    }\n\n    // struct used to store details relevant to a single middleware that an operator has opted-in to serving\n    struct MiddlewareDetails {\n        // the block before which the contract is allowed to slash the user\n        uint32 contractCanSlashOperatorUntilBlock;\n        // the block at which the middleware's view of the operator's stake was most recently updated\n        uint32 latestUpdateBlock;\n    }\n\n    /**\n     * @notice Gives the `contractAddress` permission to slash the funds of the caller.\n     * @dev Typically, this function must be called prior to registering for a middleware.\n     */\n    function optIntoSlashing(address contractAddress) external;\n\n    /**\n     * @notice Used for 'slashing' a certain operator.\n     * @param toBeFrozen The operator to be frozen.\n     * @dev Technically the operator is 'frozen' (hence the name of this function), and then subject to slashing pending a decision by a human-in-the-loop.\n     * @dev The operator must have previously given the caller (which should be a contract) the ability to slash them, through a call to `optIntoSlashing`.\n     */\n    function freezeOperator(address toBeFrozen) external;\n    \n    /**\n     * @notice Removes the 'frozen' status from each of the `frozenAddresses`\n     * @dev Callable only by the contract owner (i.e. governance).\n     */\n    function resetFrozenStatus(address[] calldata frozenAddresses) external;\n\n    /**\n     * @notice this function is a called by middlewares during an operator's registration to make sure the operator's stake at registration \n     *         is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\n     * @dev adds the middleware's slashing contract to the operator's linked list\n     */\n    function recordFirstStakeUpdate(address operator, uint32 serveUntilBlock) external;\n\n    /**\n     * @notice this function is a called by middlewares during a stake update for an operator (perhaps to free pending withdrawals)\n     *         to make sure the operator's stake at updateBlock is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param updateBlock the block for which the stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at updateBlock is slashable\n     * @param insertAfter the element of the operators linked list that the currently updating middleware should be inserted after\n     * @dev insertAfter should be calculated offchain before making the transaction that calls this. this is subject to race conditions, \n     *      but it is anticipated to be rare and not detrimental.\n     */\n    function recordStakeUpdate(address operator, uint32 updateBlock, uint32 serveUntilBlock, uint256 insertAfter) external;\n\n    /**\n     * @notice this function is a called by middlewares during an operator's deregistration to make sure the operator's stake at deregistration \n     *         is slashable until serveUntil\n     * @param operator the operator whose stake update is being recorded\n     * @param serveUntilBlock the block until which the operator's stake at the current block is slashable\n     * @dev removes the middleware's slashing contract to the operator's linked list and revokes the middleware's (i.e. caller's) ability to\n     * slash `operator` once `serveUntil` is reached\n     */\n    function recordLastStakeUpdateAndRevokeSlashingAbility(address operator, uint32 serveUntilBlock) external;\n\n    /**\n     * @notice Used to determine whether `staker` is actively 'frozen'. If a staker is frozen, then they are potentially subject to\n     * slashing of their funds, and cannot cannot deposit or withdraw from the strategyManager until the slashing process is completed\n     * and the staker's status is reset (to 'unfrozen').\n     * @param staker The staker of interest.\n     * @return Returns 'true' if `staker` themselves has their status set to frozen, OR if the staker is delegated\n     * to an operator who has their status set to frozen. Otherwise returns 'false'.\n     */\n    function isFrozen(address staker) external view returns (bool);\n\n    /// @notice Returns true if `slashingContract` is currently allowed to slash `toBeSlashed`.\n    function canSlash(address toBeSlashed, address slashingContract) external view returns (bool);\n\n    /// @notice Returns the block until which `serviceContract` is allowed to slash the `operator`.\n    function contractCanSlashOperatorUntilBlock(address operator, address serviceContract) external view returns (uint32);\n\n    /// @notice Returns the block at which the `serviceContract` last updated its view of the `operator`'s stake\n    function latestUpdateBlock(address operator, address serviceContract) external view returns (uint32);\n\n    /// @notice A search routine for finding the correct input value of `insertAfter` to `recordStakeUpdate` / `_updateMiddlewareList`.\n    function getCorrectValueForInsertAfter(address operator, uint32 updateBlock) external view returns (uint256);\n\n    /**\n     * @notice Returns 'true' if `operator` can currently complete a withdrawal started at the `withdrawalStartBlock`, with `middlewareTimesIndex` used\n     * to specify the index of a `MiddlewareTimes` struct in the operator's list (i.e. an index in `operatorToMiddlewareTimes[operator]`). The specified\n     * struct is consulted as proof of the `operator`'s ability (or lack thereof) to complete the withdrawal.\n     * This function will return 'false' if the operator cannot currently complete a withdrawal started at the `withdrawalStartBlock`, *or* in the event\n     * that an incorrect `middlewareTimesIndex` is supplied, even if one or more correct inputs exist.\n     * @param operator Either the operator who queued the withdrawal themselves, or if the withdrawing party is a staker who delegated to an operator,\n     * this address is the operator *who the staker was delegated to* at the time of the `withdrawalStartBlock`.\n     * @param withdrawalStartBlock The block number at which the withdrawal was initiated.\n     * @param middlewareTimesIndex Indicates an index in `operatorToMiddlewareTimes[operator]` to consult as proof of the `operator`'s ability to withdraw\n     * @dev The correct `middlewareTimesIndex` input should be computable off-chain.\n     */\n    function canWithdraw(address operator, uint32 withdrawalStartBlock, uint256 middlewareTimesIndex) external returns(bool);\n\n    /**\n     * operator => \n     *  [\n     *      (\n     *          the least recent update block of all of the middlewares it's serving/served, \n     *          latest time that the stake bonded at that update needed to serve until\n     *      )\n     *  ]\n     */\n    function operatorToMiddlewareTimes(address operator, uint256 arrayIndex) external view returns (MiddlewareTimes memory);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator].length`\n    function middlewareTimesLength(address operator) external view returns (uint256);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].stalestUpdateBlock`.\n    function getMiddlewareTimesIndexBlock(address operator, uint32 index) external view returns(uint32);\n\n    /// @notice Getter function for fetching `operatorToMiddlewareTimes[operator][index].latestServeUntil`.\n    function getMiddlewareTimesIndexServeUntilBlock(address operator, uint32 index) external view returns(uint32);\n\n    /// @notice Getter function for fetching `_operatorToWhitelistedContractsByUpdate[operator].size`.\n    function operatorWhitelistedContractsLinkedListSize(address operator) external view returns (uint256);\n\n    /// @notice Getter function for fetching a single node in the operator's linked list (`_operatorToWhitelistedContractsByUpdate[operator]`).\n    function operatorWhitelistedContractsLinkedListEntry(address operator, address node) external view returns (bool, uint256, uint256);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Minimal interface for an `Strategy` contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Custom `Strategy` implementations may expand extensively on this interface.\n */\ninterface IStrategy {\n    /**\n     * @notice Used to deposit tokens into this Strategy\n     * @param token is the ERC20 token being deposited\n     * @param amount is the amount of token being deposited\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * `depositIntoStrategy` function, and individual share balances are recorded in the strategyManager as well.\n     * @return newShares is the number of new shares issued at the current exchange ratio.\n     */\n    function deposit(IERC20 token, uint256 amount) external returns (uint256);\n\n    /**\n     * @notice Used to withdraw tokens from this Strategy, to the `depositor`'s address\n     * @param depositor is the address to receive the withdrawn funds\n     * @param token is the ERC20 token being transferred out\n     * @param amountShares is the amount of shares being withdrawn\n     * @dev This function is only callable by the strategyManager contract. It is invoked inside of the strategyManager's\n     * other functions, and individual share balances are recorded in the strategyManager as well.\n     */\n    function withdraw(address depositor, IERC20 token, uint256 amountShares) external;\n\n    /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlyingView`, this function **may** make state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlying(uint256 amountShares) external returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToSharesView`, this function **may** make state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of underlying tokens corresponding to the input `amountShares`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToShares(uint256 amountUnderlying) external returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlyingView`, this function **may** make state modifications\n     */\n    function userUnderlying(address user) external returns (uint256);\n\n     /**\n     * @notice Used to convert a number of shares to the equivalent amount of underlying tokens for this strategy.\n     * @notice In contrast to `sharesToUnderlying`, this function guarantees no state modifications\n     * @param amountShares is the amount of shares to calculate its conversion into the underlying token\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function sharesToUnderlyingView(uint256 amountShares) external view returns (uint256);\n\n    /**\n     * @notice Used to convert an amount of underlying tokens to the equivalent amount of shares in this strategy.\n     * @notice In contrast to `underlyingToShares`, this function guarantees no state modifications\n     * @param amountUnderlying is the amount of `underlyingToken` to calculate its conversion into strategy shares\n     * @return The amount of shares corresponding to the input `amountUnderlying`\n     * @dev Implementation for these functions in particular may vary significantly for different strategies\n     */\n    function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256);\n\n    /**\n     * @notice convenience function for fetching the current underlying value of all of the `user`'s shares in\n     * this strategy. In contrast to `userUnderlying`, this function guarantees no state modifications\n     */\n    function userUnderlyingView(address user) external view returns (uint256);\n\n    /// @notice The underlying token for shares in this Strategy\n    function underlyingToken() external view returns (IERC20);\n\n    /// @notice The total number of extant shares in this Strategy\n    function totalShares() external view returns (uint256);\n\n    /// @notice Returns either a brief string explaining the strategy's goal & purpose, or a link to metadata that explains in more detail.\n    function explanation() external view returns (string memory);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IStrategyManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nimport \"./IStrategy.sol\";\nimport \"./ISlasher.sol\";\nimport \"./IDelegationManager.sol\";\n\n/**\n * @title Interface for the primary entrypoint for funds into EigenLayer.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice See the `StrategyManager` contract itself for implementation details.\n */\ninterface IStrategyManager {\n\n    // Access to public vars - hack locally\n    function stakerStrategyList(address staker, uint256 index) external view returns (IStrategy);\n    function numWithdrawalsQueued(address staker) external view returns (uint256);\n\n    // packed struct for queued withdrawals; helps deal with stack-too-deep errors\n    struct WithdrawerAndNonce {\n        address withdrawer;\n        uint96 nonce;\n    }\n\n    /**\n     * Struct type used to specify an existing queued withdrawal. Rather than storing the entire struct, only a hash is stored.\n     * In functions that operate on existing queued withdrawals -- e.g. `startQueuedWithdrawalWaitingPeriod` or `completeQueuedWithdrawal`,\n     * the data is resubmitted and the hash of the submitted data is computed by `calculateWithdrawalRoot` and checked against the\n     * stored hash in order to confirm the integrity of the submitted data.\n     */\n    struct QueuedWithdrawal {\n        IStrategy[] strategies;\n        uint256[] shares;\n        address depositor;\n        WithdrawerAndNonce withdrawerAndNonce;\n        uint32 withdrawalStartBlock;\n        address delegatedAddress;\n    }\n\n    /**\n     * @notice Deposits `amount` of `token` into the specified `strategy`, with the resultant shares credited to `msg.sender`\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the depositor\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev Cannot be called by an address that is 'frozen' (this function will revert if the `msg.sender` is frozen).\n     * \n     * WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy.\n     */\n    function depositIntoStrategy(IStrategy strategy, IERC20 token, uint256 amount)\n        external\n        returns (uint256 shares);\n\n\n    /**\n     * @notice Deposits `amount` of beaconchain ETH into this contract on behalf of `staker`\n     * @param staker is the entity that is restaking in eigenlayer,\n     * @param amount is the amount of beaconchain ETH being restaked,\n     * @dev Only callable by EigenPodManager.\n     */\n    function depositBeaconChainETH(address staker, uint256 amount) external;\n\n    /**\n     * @notice Records an overcommitment event on behalf of a staker. The staker's beaconChainETH shares are decremented by `amount`.\n     * @param overcommittedPodOwner is the pod owner to be slashed\n     * @param beaconChainETHStrategyIndex is the index of the beaconChainETHStrategy in case it must be removed,\n     * @param amount is the amount to decrement the slashedAddress's beaconChainETHStrategy shares\n     * @dev Only callable by EigenPodManager.\n     */\n    function recordOvercommittedBeaconChainETH(address overcommittedPodOwner, uint256 beaconChainETHStrategyIndex, uint256 amount)\n        external;\n\n    /**\n     * @notice Used for depositing an asset into the specified strategy with the resultant shares credited to `staker`,\n     * who must sign off on the action.\n     * Note that the assets are transferred out/from the `msg.sender`, not from the `staker`; this function is explicitly designed \n     * purely to help one address deposit 'for' another.\n     * @param strategy is the specified strategy where deposit is to be made,\n     * @param token is the denomination in which the deposit is to be made,\n     * @param amount is the amount of token to be deposited in the strategy by the depositor\n     * @param staker the staker that the deposited assets will be credited to\n     * @param expiry the timestamp at which the signature expires\n     * @param signature is a valid signature from the `staker`. either an ECDSA signature if the `staker` is an EOA, or data to forward\n     * following EIP-1271 if the `staker` is a contract\n     * @return shares The amount of new shares in the `strategy` created as part of the action.\n     * @dev The `msg.sender` must have previously approved this contract to transfer at least `amount` of `token` on their behalf.\n     * @dev A signature is required for this function to eliminate the possibility of griefing attacks, specifically those\n     * targeting stakers who may be attempting to undelegate.\n     * @dev Cannot be called on behalf of a staker that is 'frozen' (this function will revert if the `staker` is frozen).\n     * \n     *  WARNING: Depositing tokens that allow reentrancy (eg. ERC-777) into a strategy is not recommended.  This can lead to attack vectors\n     *          where the token balance and corresponding strategy shares are not in sync upon reentrancy\n     */\n    function depositIntoStrategyWithSignature(\n        IStrategy strategy,\n        IERC20 token,\n        uint256 amount,\n        address staker,\n        uint256 expiry,\n        bytes memory signature\n    )\n        external\n        returns (uint256 shares);\n\n    /// @notice Returns the current shares of `user` in `strategy`\n    function stakerStrategyShares(address user, IStrategy strategy) external view returns (uint256 shares);\n\n    /**\n     * @notice Get all details on the depositor's deposits and corresponding shares\n     * @return (depositor's strategies, shares in these strategies)\n     */\n    function getDeposits(address depositor) external view returns (IStrategy[] memory, uint256[] memory);\n\n    /// @notice Simple getter function that returns `stakerStrategyList[staker].length`.\n    function stakerStrategyListLength(address staker) external view returns (uint256);\n\n    /**\n     * @notice Called by a staker to queue a withdrawal of the given amount of `shares` from each of the respective given `strategies`.\n     * @dev Stakers will complete their withdrawal by calling the 'completeQueuedWithdrawal' function.\n     * User shares are decreased in this function, but the total number of shares in each strategy remains the same.\n     * The total number of shares is decremented in the 'completeQueuedWithdrawal' function instead, which is where\n     * the funds are actually sent to the user through use of the strategies' 'withdrawal' function. This ensures\n     * that the value per share reported by each strategy will remain consistent, and that the shares will continue\n     * to accrue gains during the enforced withdrawal waiting period.\n     * @param strategyIndexes is a list of the indices in `stakerStrategyList[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param strategies The Strategies to withdraw from\n     * @param shares The amount of shares to withdraw from each of the respective Strategies in the `strategies` array\n     * @param withdrawer The address that can complete the withdrawal and will receive any withdrawn funds or shares upon completing the withdrawal\n     * @param undelegateIfPossible If this param is marked as 'true' *and the withdrawal will result in `msg.sender` having no shares in any Strategy,*\n     * then this function will also make an internal call to `undelegate(msg.sender)` to undelegate the `msg.sender`.\n     * @return The 'withdrawalRoot' of the newly created Queued Withdrawal\n     * @dev Strategies are removed from `stakerStrategyList` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `stakerStrategyList`. The simplest way to calculate the correct `strategyIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `stakerStrategyList` to lowest index\n     * @dev Note that if the withdrawal includes shares in the enshrined 'beaconChainETH' strategy, then it must *only* include shares in this strategy, and\n     * `withdrawer` must match the caller's address. The first condition is because slashing of queued withdrawals cannot be guaranteed \n     * for Beacon Chain ETH (since we cannot trigger a withdrawal from the beacon chain through a smart contract) and the second condition is because shares in\n     * the enshrined 'beaconChainETH' strategy technically represent non-fungible positions (deposits to the Beacon Chain, each pointed at a specific EigenPod).\n     */\n    function queueWithdrawal(\n        uint256[] calldata strategyIndexes,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares,\n        address withdrawer,\n        bool undelegateIfPossible\n    )\n        external returns(bytes32);\n        \n    /**\n     * @notice Used to complete the specified `queuedWithdrawal`. The function caller must match `queuedWithdrawal.withdrawer`\n     * @param queuedWithdrawal The QueuedWithdrawal to complete.\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `strategies` array\n     * of the `queuedWithdrawal`. This input can be provided with zero length if `receiveAsTokens` is set to 'false' (since in that case, this input will be unused)\n     * @param middlewareTimesIndex is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array\n     * @param receiveAsTokens If true, the shares specified in the queued withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `queuedWithdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\n     */\n    function completeQueuedWithdrawal(\n        QueuedWithdrawal calldata queuedWithdrawal,\n        IERC20[] calldata tokens,\n        uint256 middlewareTimesIndex,\n        bool receiveAsTokens\n    )\n        external;\n    \n    /**\n     * @notice Used to complete the specified `queuedWithdrawals`. The function caller must match `queuedWithdrawals[...].withdrawer`\n     * @param queuedWithdrawals The QueuedWithdrawals to complete.\n     * @param tokens Array of tokens for each QueuedWithdrawal. See `completeQueuedWithdrawal` for the usage of a single array.\n     * @param middlewareTimesIndexes One index to reference per QueuedWithdrawal. See `completeQueuedWithdrawal` for the usage of a single index.\n     * @param receiveAsTokens If true, the shares specified in the queued withdrawal will be withdrawn from the specified strategies themselves\n     * and sent to the caller, through calls to `queuedWithdrawal.strategies[i].withdraw`. If false, then the shares in the specified strategies\n     * will simply be transferred to the caller directly.\n     * @dev Array-ified version of `completeQueuedWithdrawal`\n     * @dev middlewareTimesIndex should be calculated off chain before calling this function by finding the first index that satisfies `slasher.canWithdraw`\n     */\n    function completeQueuedWithdrawals(\n        QueuedWithdrawal[] calldata queuedWithdrawals,\n        IERC20[][] calldata tokens,\n        uint256[] calldata middlewareTimesIndexes,\n        bool[] calldata receiveAsTokens\n    )\n        external;\n\n    /**\n     * @notice Slashes the shares of a 'frozen' operator (or a staker delegated to one)\n     * @param slashedAddress is the frozen address that is having its shares slashed\n     * @param recipient is the address that will receive the slashed funds, which could e.g. be a harmed party themself,\n     * or a MerkleDistributor-type contract that further sub-divides the slashed funds.\n     * @param strategies Strategies to slash\n     * @param shareAmounts The amount of shares to slash in each of the provided `strategies`\n     * @param tokens The tokens to use as input to the `withdraw` function of each of the provided `strategies`\n     * @param strategyIndexes is a list of the indices in `stakerStrategyList[msg.sender]` that correspond to the strategies\n     * for which `msg.sender` is withdrawing 100% of their shares\n     * @param recipient The slashed funds are withdrawn as tokens to this address.\n     * @dev strategies are removed from `stakerStrategyList` by swapping the last entry with the entry to be removed, then\n     * popping off the last entry in `stakerStrategyList`. The simplest way to calculate the correct `strategyIndexes` to input\n     * is to order the strategies *for which `msg.sender` is withdrawing 100% of their shares* from highest index in\n     * `stakerStrategyList` to lowest index\n     */\n    function slashShares(\n        address slashedAddress,\n        address recipient,\n        IStrategy[] calldata strategies,\n        IERC20[] calldata tokens,\n        uint256[] calldata strategyIndexes,\n        uint256[] calldata shareAmounts\n    )\n        external;\n\n    /**\n     * @notice Slashes an existing queued withdrawal that was created by a 'frozen' operator (or a staker delegated to one)\n     * @param recipient The funds in the slashed withdrawal are withdrawn as tokens to this address.\n     * @param queuedWithdrawal The previously queued withdrawal to be slashed\n     * @param tokens Array in which the i-th entry specifies the `token` input to the 'withdraw' function of the i-th Strategy in the `strategies`\n     * array of the `queuedWithdrawal`.\n     * @param indicesToSkip Optional input parameter -- indices in the `strategies` array to skip (i.e. not call the 'withdraw' function on). This input exists\n     * so that, e.g., if the slashed QueuedWithdrawal contains a malicious strategy in the `strategies` array which always reverts on calls to its 'withdraw' function,\n     * then the malicious strategy can be skipped (with the shares in effect \"burned\"), while the non-malicious strategies are still called as normal.\n     */\n    function slashQueuedWithdrawal(address recipient, QueuedWithdrawal calldata queuedWithdrawal, IERC20[] calldata tokens, uint256[] calldata indicesToSkip)\n        external;\n\n    /// @notice Returns the keccak256 hash of `queuedWithdrawal`.\n    function calculateWithdrawalRoot(\n        QueuedWithdrawal memory queuedWithdrawal\n    )\n        external\n        pure\n        returns (bytes32);\n\n    /**\n     * @notice Owner-only function that adds the provided Strategies to the 'whitelist' of strategies that stakers can deposit into\n     * @param strategiesToWhitelist Strategies that will be added to the `strategyIsWhitelistedForDeposit` mapping (if they aren't in it already)\n    */\n    function addStrategiesToDepositWhitelist(IStrategy[] calldata strategiesToWhitelist) external;\n\n    /**\n     * @notice Owner-only function that removes the provided Strategies from the 'whitelist' of strategies that stakers can deposit into\n     * @param strategiesToRemoveFromWhitelist Strategies that will be removed to the `strategyIsWhitelistedForDeposit` mapping (if they are in it)\n    */\n    function removeStrategiesFromDepositWhitelist(IStrategy[] calldata strategiesToRemoveFromWhitelist) external;\n\n    /// @notice Returns the single, central Delegation contract of EigenLayer\n    function delegation() external view returns (IDelegationManager);\n\n    /// @notice Returns the single, central Slasher contract of EigenLayer\n    function slasher() external view returns (ISlasher);\n\n    /// @notice returns the enshrined, virtual 'beaconChainETH' Strategy\n    function beaconChainETHStrategy() external view returns (IStrategy);\n\n    /// @notice Returns the number of blocks that must pass between the time a withdrawal is queued and the time it can be completed\n    function withdrawalDelayBlocks() external view returns (uint256);\n}\n"
    },
    "contracts/EigenLayer/interfaces/IVoteWeigher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\n/**\n * @title Interface for a `VoteWeigher`-type contract.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Note that `NUMBER_OF_QUORUMS` is expected to remain constant, as suggested by its uppercase formatting.\n */\ninterface IVoteWeigher {\n    /**\n     * @notice This function computes the total weight of the @param operator in the quorum @param quorumNumber.\n     * @dev returns zero in the case that `quorumNumber` is greater than or equal to `NUMBER_OF_QUORUMS`\n     */\n    function weightOfOperator(address operator, uint256 quorumNumber) external returns (uint96);\n\n    /// @notice Number of quorums that are being used by the middleware.\n    function NUMBER_OF_QUORUMS() external view returns (uint256);\n\n    /**\n     * @notice This defines the earnings split between different quorums. Mapping is quorumNumber => BIPS which the quorum earns, out of the total earnings.\n     * @dev The sum of all entries, i.e. sum(quorumBips[0] through quorumBips[NUMBER_OF_QUORUMS - 1]) should *always* be 10,000!\n     */\n    function quorumBips(uint256 quorumNumber) external view returns (uint256);\n}\n"
    },
    "contracts/EigenLayer/libraries/BeaconChainProofs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.19;\n\nimport \"./Merkle.sol\";\nimport \"../libraries/Endian.sol\";\n\n//Utility library for parsing and PHASE0 beacon chain block headers\n//SSZ Spec: https://github.com/ethereum/consensus-specs/blob/dev/ssz/simple-serialize.md#merkleization\n//BeaconBlockHeader Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconblockheader\n//BeaconState Spec: https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#beaconstate\nlibrary BeaconChainProofs {\n    // constants are the number of fields and the heights of the different merkle trees used in merkleizing beacon chain containers\n    uint256 internal constant NUM_BEACON_BLOCK_HEADER_FIELDS = 5;\n    uint256 internal constant BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_BEACON_BLOCK_BODY_FIELDS = 11;\n    uint256 internal constant BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT = 4;\n\n    uint256 internal constant NUM_BEACON_STATE_FIELDS = 21;\n    uint256 internal constant BEACON_STATE_FIELD_TREE_HEIGHT = 5;\n\n    uint256 internal constant NUM_ETH1_DATA_FIELDS = 3;\n    uint256 internal constant ETH1_DATA_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant NUM_VALIDATOR_FIELDS = 8;\n    uint256 internal constant VALIDATOR_FIELD_TREE_HEIGHT = 3;\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_HEADER_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT = 4;\n\n\n    uint256 internal constant NUM_EXECUTION_PAYLOAD_FIELDS = 15;\n    uint256 internal constant EXECUTION_PAYLOAD_FIELD_TREE_HEIGHT = 4;\n\n\n    // HISTORICAL_ROOTS_LIMIT\t = 2**24, so tree height is 24\n    uint256 internal constant HISTORICAL_ROOTS_TREE_HEIGHT = 24;\n\n    // HISTORICAL_BATCH is root of state_roots and block_root, so number of leaves =  2^1\n    uint256 internal constant HISTORICAL_BATCH_TREE_HEIGHT = 1;\n\n    // SLOTS_PER_HISTORICAL_ROOT = 2**13, so tree height is 13\n    uint256 internal constant STATE_ROOTS_TREE_HEIGHT = 13;\n    uint256 internal constant BLOCK_ROOTS_TREE_HEIGHT = 13;\n\n\n    uint256 internal constant NUM_WITHDRAWAL_FIELDS = 4;\n    // tree height for hash tree of an individual withdrawal container\n    uint256 internal constant WITHDRAWAL_FIELD_TREE_HEIGHT = 2;\n\n    uint256 internal constant VALIDATOR_TREE_HEIGHT = 40;\n    //refer to the eigenlayer-cli proof library.  Despite being the same dimensions as the validator tree, the balance tree is merkleized differently\n    uint256 internal constant BALANCE_TREE_HEIGHT = 38;\n\n    // MAX_WITHDRAWALS_PER_PAYLOAD = 2**4, making tree height = 4\n    uint256 internal constant WITHDRAWALS_TREE_HEIGHT = 4;\n\n    //in beacon block body\n    uint256 internal constant EXECUTION_PAYLOAD_INDEX = 9;\n\n    // in beacon block header\n    uint256 internal constant STATE_ROOT_INDEX = 3;\n    uint256 internal constant PROPOSER_INDEX_INDEX = 1;\n    uint256 internal constant SLOT_INDEX = 0;\n    uint256 internal constant BODY_ROOT_INDEX = 4;\n    // in beacon state\n    uint256 internal constant STATE_ROOTS_INDEX = 6;\n    uint256 internal constant BLOCK_ROOTS_INDEX = 5;\n    uint256 internal constant HISTORICAL_ROOTS_INDEX = 7;\n    uint256 internal constant ETH_1_ROOT_INDEX = 8;\n    uint256 internal constant VALIDATOR_TREE_ROOT_INDEX = 11;\n    uint256 internal constant BALANCE_INDEX = 12;\n    uint256 internal constant EXECUTION_PAYLOAD_HEADER_INDEX = 24;\n    uint256 internal constant HISTORICAL_BATCH_STATE_ROOT_INDEX = 1;\n\n    // in validator\n    uint256 internal constant VALIDATOR_WITHDRAWAL_CREDENTIALS_INDEX = 1;\n    uint256 internal constant VALIDATOR_BALANCE_INDEX = 2;\n    uint256 internal constant VALIDATOR_SLASHED_INDEX = 3;\n    uint256 internal constant VALIDATOR_WITHDRAWABLE_EPOCH_INDEX = 7;\n    \n    // in execution payload header\n    uint256 internal constant BLOCK_NUMBER_INDEX = 6;\n    uint256 internal constant WITHDRAWALS_ROOT_INDEX = 14;\n\n    //in execution payload\n    uint256 internal constant WITHDRAWALS_INDEX = 14;\n\n    // in withdrawal\n    uint256 internal constant WITHDRAWAL_VALIDATOR_INDEX_INDEX = 1;\n    uint256 internal constant WITHDRAWAL_VALIDATOR_AMOUNT_INDEX = 3;\n\n    //In historicalBatch\n    uint256 internal constant HISTORICALBATCH_STATEROOTS_INDEX = 1;\n\n    //Misc Constants\n    uint256 internal constant SLOTS_PER_EPOCH = 32;\n\n    bytes8 internal constant UINT64_MASK = 0xffffffffffffffff;\n\n\n\n    struct WithdrawalProofs {\n        bytes blockHeaderProof;\n        bytes withdrawalProof;\n        bytes slotProof;\n        bytes executionPayloadProof;\n        bytes blockNumberProof;\n        uint64 blockHeaderRootIndex;\n        uint64 withdrawalIndex;\n        bytes32 blockHeaderRoot;\n        bytes32 blockBodyRoot;\n        bytes32 slotRoot;\n        bytes32 blockNumberRoot;\n        bytes32 executionPayloadRoot;\n    }\n\n    struct ValidatorFieldsAndBalanceProofs {\n        bytes validatorFieldsProof;\n        bytes validatorBalanceProof;\n        bytes32 balanceRoot;\n    }\n\n    struct ValidatorFieldsProof {\n        bytes validatorProof;\n        uint40 validatorIndex;\n    }\n\n    /**\n     * \n     * @notice This function is parses the balanceRoot to get the uint64 balance of a validator.  During merkleization of the\n     * beacon state balance tree, four uint64 values (making 32 bytes) are grouped together and treated as a single leaf in the merkle tree. Thus the\n     * validatorIndex mod 4 is used to determine which of the four uint64 values to extract from the balanceRoot.\n     * @param validatorIndex is the index of the validator being proven for.\n     * @param balanceRoot is the combination of 4 validator balances being proven for.\n     * @return The validator's balance, in Gwei\n     */\n   function getBalanceFromBalanceRoot(uint40 validatorIndex, bytes32 balanceRoot) internal pure returns (uint64) {\n        uint256 bitShiftAmount = (validatorIndex % 4) * 64;\n        bytes32 validatorBalanceLittleEndian = bytes32((uint256(balanceRoot) << bitShiftAmount));\n        uint64 validatorBalance = Endian.fromLittleEndianUint64(validatorBalanceLittleEndian);\n        return validatorBalance;\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the fields of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the data used in proving the validator's fields\n     * @param validatorFields the claimed fields of the validator\n     */\n    function verifyValidatorFields(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof, \n        bytes32[] calldata validatorFields\n    ) internal view {\n        \n        require(validatorFields.length == 2**VALIDATOR_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyValidatorFields: Validator fields has incorrect length\");\n\n        /**\n         * Note: the length of the validator merkle proof is BeaconChainProofs.VALIDATOR_TREE_HEIGHT + 1.\n         * There is an additional layer added by hashing the root with the length of the validator list\n         */\n        require(proof.length == 32 * ((VALIDATOR_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorFields: Proof has incorrect length\");\n        uint256 index = (VALIDATOR_TREE_ROOT_INDEX << (VALIDATOR_TREE_HEIGHT + 1)) | uint256(validatorIndex);\n        // merkleize the validatorFields to get the leaf to prove\n        bytes32 validatorRoot = Merkle.merkleizeSha256(validatorFields);\n\n        // verify the proof of the validatorRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, validatorRoot, index), \"BeaconChainProofs.verifyValidatorFields: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies merkle proofs of the balance of a certain validator against a beacon chain state root\n     * @param validatorIndex the index of the proven validator\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proof is the proof of the balance against the beacon chain state root\n     * @param balanceRoot is the serialized balance used to prove the balance of the validator (refer to `getBalanceFromBalanceRoot` above for detailed explanation)\n     */\n    function verifyValidatorBalance(\n        uint40 validatorIndex,\n        bytes32 beaconStateRoot,\n        bytes calldata proof,\n        bytes32 balanceRoot\n    ) internal view {\n        require(proof.length == 32 * ((BALANCE_TREE_HEIGHT + 1) + BEACON_STATE_FIELD_TREE_HEIGHT), \"BeaconChainProofs.verifyValidatorBalance: Proof has incorrect length\");\n\n        /**\n        * the beacon state's balance list is a list of uint64 values, and these are grouped together in 4s when merkleized.  \n        * Therefore, the index of the balance of a validator is validatorIndex/4\n        */\n        uint256 balanceIndex = uint256(validatorIndex/4);\n        balanceIndex = (BALANCE_INDEX << (BALANCE_TREE_HEIGHT + 1)) | balanceIndex;\n\n        require(Merkle.verifyInclusionSha256(proof, beaconStateRoot, balanceRoot, balanceIndex), \"BeaconChainProofs.verifyValidatorBalance: Invalid merkle proof\");\n    }\n\n    /**\n     * @notice This function verifies the slot and the withdrawal fields for a given withdrawal\n     * @param beaconStateRoot is the beacon chain state root to be proven against.\n     * @param proofs is the provided set of merkle proofs\n     * @param withdrawalFields is the serialized withdrawal container to be proven\n     */\n    function verifyWithdrawalProofs(\n        bytes32 beaconStateRoot,\n        WithdrawalProofs calldata proofs,\n        bytes32[] calldata withdrawalFields\n    ) internal view {\n        require(withdrawalFields.length == 2**WITHDRAWAL_FIELD_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalFields has incorrect length\");\n\n        require(proofs.blockHeaderRootIndex < 2**BLOCK_ROOTS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: blockRootIndex is too large\");\n        require(proofs.withdrawalIndex < 2**WITHDRAWALS_TREE_HEIGHT, \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalIndex is too large\");\n       \n        // verify the block header proof length\n        require(proofs.blockHeaderProof.length == 32 * (BEACON_STATE_FIELD_TREE_HEIGHT + BLOCK_ROOTS_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: blockHeaderProof has incorrect length\");\n        require(proofs.withdrawalProof.length == 32 * (EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT + WITHDRAWALS_TREE_HEIGHT + 1),\n            \"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length\");\n        require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length\");\n        require(proofs.slotProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: slotProof has incorrect length\");\n        require(proofs.blockNumberProof.length == 32 * (EXECUTION_PAYLOAD_HEADER_FIELD_TREE_HEIGHT),\n            \"BeaconChainProofs.verifyWithdrawalProofs: blockNumberProof has incorrect length\");\n\n\n        /**\n         * Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the\n         * intermediate root indexes from the bottom of the sub trees (the block header container) to the top of the tree\n         */\n        uint256 blockHeaderIndex = BLOCK_ROOTS_INDEX << (BLOCK_ROOTS_TREE_HEIGHT)  | uint256(proofs.blockHeaderRootIndex);\n        // Verify the blockHeaderRoot against the beaconStateRoot\n        require(Merkle.verifyInclusionSha256(proofs.blockHeaderProof, beaconStateRoot, proofs.blockHeaderRoot, blockHeaderIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid block header merkle proof\");\n\n        //Next we verify the slot against the blockHeaderRoot\n        require(Merkle.verifyInclusionSha256(proofs.slotProof, proofs.blockHeaderRoot, proofs.slotRoot, SLOT_INDEX), \"BeaconChainProofs.verifyWithdrawalProofs: Invalid slot merkle proof\");\n\n        // Next we verify the executionPayloadRoot against the blockHeaderRoot\n        uint256 executionPayloadIndex = BODY_ROOT_INDEX << (BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT)| EXECUTION_PAYLOAD_INDEX ;\n        require(Merkle.verifyInclusionSha256(proofs.executionPayloadProof, proofs.blockHeaderRoot, proofs.executionPayloadRoot, executionPayloadIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid executionPayload merkle proof\");\n\n        // Next we verify the blockNumberRoot against the executionPayload root\n        require(Merkle.verifyInclusionSha256(proofs.blockNumberProof, proofs.executionPayloadRoot, proofs.blockNumberRoot, BLOCK_NUMBER_INDEX),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid blockNumber merkle proof\");\n\n        /**\n         * Next we verify the withdrawal fields against the blockHeaderRoot:\n         * First we compute the withdrawal_index relative to the blockHeaderRoot by concatenating the indexes of all the \n         * intermediate root indexes from the bottom of the sub trees (the withdrawal container) to the top, the blockHeaderRoot.\n         * Then we calculate merkleize the withdrawalFields container to calculate the the withdrawalRoot.\n         * Finally we verify the withdrawalRoot against the executionPayloadRoot.\n         */\n        uint256 withdrawalIndex = WITHDRAWALS_INDEX << (WITHDRAWALS_TREE_HEIGHT + 1) | uint256(proofs.withdrawalIndex);\n        bytes32 withdrawalRoot = Merkle.merkleizeSha256(withdrawalFields);\n        require(Merkle.verifyInclusionSha256(proofs.withdrawalProof, proofs.executionPayloadRoot, withdrawalRoot, withdrawalIndex),\n            \"BeaconChainProofs.verifyWithdrawalProofs: Invalid withdrawal merkle proof\");\n    }\n\n}"
    },
    "contracts/EigenLayer/libraries/BN254.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1 AND MIT\n// several functions are taken or adapted from https://github.com/HarryR/solcrypto/blob/master/contracts/altbn128.sol (MIT license):\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// The remainder of the code is written by LayrLabs Inc. and is under the BUSL-1.1 license\n\npragma solidity =0.8.19;\n\n/**\n * @title Library for operations on the BN254 elliptic curve.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n * @notice Contains BN254 parameters, common operations (addition, scalar mul, pairing), and BLS signature functionality.\n */\nlibrary BN254 {\n    // modulus for the underlying field F_p of the elliptic curve\n    uint256 internal constant FP_MODULUS =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    // modulus for the underlying field F_r of the elliptic curve\n    uint256 internal constant FR_MODULUS =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    // Encoding of field elements is: X[1] * i + X[0]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    // generator of group G2\n    /// @dev Generator point in F_q2 is of the form: (x0 + ix1, y0 + iy1).\n    uint256 internal constant G2x1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 internal constant G2x0 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 internal constant G2y1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 internal constant G2y0 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    /// @notice returns the G2 generator\n    /// @dev mind the ordering of the 1s and 0s!\n    ///      this is because of the (unknown to us) convention used in the bn254 pairing precompile contract\n    ///      \"Elements a * i + b of F_p^2 are encoded as two elements of F_p, (a, b).\"\n    ///      https://github.com/ethereum/EIPs/blob/master/EIPS/eip-197.md#encoding\n    function generatorG2() internal pure returns (G2Point memory) {\n        return G2Point(\n            [G2x1, G2x0], [G2y1, G2y0]\n        );\n    }\n\n    // negation of the generator of group G2\n    /// @dev Generator point in F_q2 is of the form: (x0 + ix1, y0 + iy1).\n    uint256 internal constant nG2x1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 internal constant nG2x0 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 internal constant nG2y1 =\n        17805874995975841540914202342111839520379459829704422454583296818431106115052;\n    uint256 internal constant nG2y0 =\n        13392588948715843804641432497768002650278120570034223513918757245338268106653;\n    function negGeneratorG2() internal pure returns (G2Point memory) {\n        return G2Point(\n            [nG2x1, nG2x0], [nG2y1, nG2y0]\n        );\n    }\n\n    bytes32 internal constant powersOfTauMerkleRoot =\n        0x22c998e49752bbb1918ba87d6d59dd0e83620a311ba91dd4b2cc84990b31b56f;\n\n\n    /**\n     * @param p Some point in G1.\n     * @return The negation of `p`, i.e. p.plus(p.negate()) should be zero.\n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, FP_MODULUS - (p.Y % FP_MODULUS));\n        }\n    }\n\n    /**\n     * @return r the sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0x80, r, 0x40)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"ec-add-failed\");\n    }\n\n    /**\n     * @return r the product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(\n        G1Point memory p,\n        uint256 s\n    ) internal view returns (G1Point memory r) {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x60, r, 0x40)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"ec-mul-failed\");\n    }\n\n    /**\n     *  @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2\n    ) internal view returns (bool) {\n        G1Point[2] memory p1 = [a1, b1];\n        G2Point[2] memory p2 = [a2, b2];\n\n        uint256[12] memory input;\n\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(\n                sub(gas(), 2000),\n                8,\n                input,\n                mul(12, 0x20),\n                out,\n                0x20\n            )\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        return out[0] != 0;\n    }\n\n    /**\n     * @notice This function is functionally the same as pairing(), however it specifies a gas limit\n     *         the user can set, as a precompile may use the entire gas budget if it reverts.\n     */\n    function safePairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        uint256 pairingGas\n    ) internal view returns (bool, bool) {\n        G1Point[2] memory p1 = [a1, b1];\n        G2Point[2] memory p2 = [a2, b2];\n\n        uint256[12] memory input;\n\n        for (uint256 i = 0; i < 2; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(\n                pairingGas,\n                8,\n                input,\n                mul(12, 0x20),\n                out,\n                0x20\n            )\n        }\n\n        //Out is the output of the pairing precompile, either 0 or 1 based on whether the two pairings are equal.\n        //Success is true if the precompile actually goes through (aka all inputs are valid)\n\n        return (success, out[0] != 0);\n    }\n\n    /// @return the keccak256 hash of the G1 Point\n    /// @dev used for BLS signatures\n    function hashG1Point(\n        BN254.G1Point memory pk\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(pk.X, pk.Y));\n    }\n\n\n    /**\n     * @notice adapted from https://github.com/HarryR/solcrypto/blob/master/contracts/altbn128.sol\n     */\n    function hashToG1(bytes32 _x) internal view returns (uint256, uint256) {\n        uint256 beta = 0;\n        uint256 y = 0;\n\n        // XXX: Gen Order (n) or Field Order (p) ?\n        uint256 x = uint256(_x) % FP_MODULUS;\n\n        while( true ) {\n            (beta, y) = findYFromX(x);\n\n            // y^2 == beta\n            if( beta == mulmod(y, y, FP_MODULUS) ) {\n                return (x, y);\n            }\n\n            x = addmod(x, 1, FP_MODULUS);\n        }\n        return (0, 0);\n    }\n\n    /**\n    * Given X, find Y\n    *\n    *   where y = sqrt(x^3 + b)\n    *\n    * Returns: (x^3 + b), y\n    */\n    function findYFromX(uint256 x)\n        internal view returns(uint256, uint256)\n    {\n        // beta = (x^3 + b) % p\n        uint256 beta = addmod(mulmod(mulmod(x, x, FP_MODULUS), x, FP_MODULUS), 3, FP_MODULUS);\n\n        // y^2 = x^3 + b\n        // this acts like: y = sqrt(beta) = beta^((p+1) / 4)\n        uint256 y = expMod(beta, 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52, FP_MODULUS);\n\n        return (beta, y);\n    }\n\n    function expMod(uint256 _base, uint256 _exponent, uint256 _modulus) internal view returns (uint256 retval) {\n        bool success;\n        uint256[1] memory output;\n        uint[6] memory input;\n        input[0] = 0x20;        // baseLen = new(big.Int).SetBytes(getData(input, 0, 32))\n        input[1] = 0x20;        // expLen  = new(big.Int).SetBytes(getData(input, 32, 32))\n        input[2] = 0x20;        // modLen  = new(big.Int).SetBytes(getData(input, 64, 32))\n        input[3] = _base;\n        input[4] = _exponent;\n        input[5] = _modulus;\n        assembly {\n            success := staticcall(sub(gas(), 2000), 5, input, 0xc0, output, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require(success, \"BN254.expMod: call failure\");\n        return output[0];\n    }\n}\n"
    },
    "contracts/EigenLayer/libraries/BytesArrayBitmaps.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.19;\n\n/**\n * @title Library for converting between an array of bytes and a bitmap.\n * @author Layr Labs, Inc.\n */\nlibrary BytesArrayBitmaps {\n    /**\n     * @notice Byte arrays are meant to contain unique bytes.\n     * If the array length exceeds 256, then it's impossible for all entries to be unique.\n     * This constant captures the max allowed array length (inclusive, i.e. 256 is allowed).\n     */\n    uint256 constant MAX_BYTE_ARRAY_LENGTH = 256;\n\n    /**\n     * @notice Converts an array of bytes into a bitmap.\n     * @param bytesArray The array of bytes to convert/compress into a bitmap.\n     * @return The resulting bitmap.\n     * @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap\n     * @dev This function will also revert if the `bytesArray` input contains any duplicate entries (i.e. duplicate bytes).\n     */\n    function bytesArrayToBitmap(bytes calldata bytesArray) internal pure returns (uint256) {\n        // sanity-check on input. a too-long input would fail later on due to having duplicate entry(s)\n        require(bytesArray.length <= MAX_BYTE_ARRAY_LENGTH,\n            \"BytesArrayBitmaps.bytesArrayToBitmap: bytesArray is too long\");\n\n        // return empty bitmap early if length of array is 0\n        if (bytesArray.length == 0) {\n            return uint256(0);\n        }\n\n        // initialize the empty bitmap, to be built inside the loop\n        uint256 bitmap;\n        // initialize an empty uint256 to be used as a bitmask inside the loop\n        uint256 bitMask;\n\n        // perform the 0-th loop iteration with the ordering check *omitted* (since it is unnecessary / will always pass)\n        // construct a single-bit mask from the numerical value of the 0th byte of the array, and immediately add it to the bitmap\n        bitmap = uint256(1 << uint8(bytesArray[0]));\n\n        // loop through each byte in the array to construct the bitmap\n        for (uint256 i = 1; i < bytesArray.length; ++i) {\n            // construct a single-bit mask from the numerical value of the next byte out of the array\n            bitMask = uint256(1 << uint8(bytesArray[i]));\n            // check that the entry is not a repeat\n            require(bitmap & bitMask == 0, \"BytesArrayBitmaps.bytesArrayToBitmap: repeat entry in bytesArray\");\n            // add the entry to the bitmap\n            bitmap = (bitmap | bitMask);\n        }\n        return bitmap;\n    }\n\n    /**\n     * @notice Converts an ordered array of bytes into a bitmap.\n     * @param orderedBytesArray The array of bytes to convert/compress into a bitmap. Must be in strictly ascending order.\n     * @return The resulting bitmap.\n     * @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap.\n     * @dev This function will eventually revert in the event that the `orderedBytesArray` is not properly ordered (in ascending order).\n     * @dev This function will also revert if the `orderedBytesArray` input contains any duplicate entries (i.e. duplicate bytes).\n     */\n    function orderedBytesArrayToBitmap(bytes calldata orderedBytesArray) internal pure returns (uint256) {\n        // sanity-check on input. a too-long input would fail later on due to having duplicate entry(s)\n        require(orderedBytesArray.length <= MAX_BYTE_ARRAY_LENGTH,\n            \"BytesArrayBitmaps.orderedBytesArrayToBitmap: orderedBytesArray is too long\");\n\n        // return empty bitmap early if length of array is 0\n        if (orderedBytesArray.length == 0) {\n            return uint256(0);\n        }\n\n        // initialize the empty bitmap, to be built inside the loop\n        uint256 bitmap;\n        // initialize an empty uint256 to be used as a bitmask inside the loop\n        uint256 bitMask;\n\n        // perform the 0-th loop iteration with the ordering check *omitted* (since it is unnecessary / will always pass)\n        // construct a single-bit mask from the numerical value of the 0th byte of the array, and immediately add it to the bitmap\n        bitmap = uint256(1 << uint8(orderedBytesArray[0]));\n\n        // loop through each byte in the array to construct the bitmap\n        for (uint256 i = 1; i < orderedBytesArray.length; ++i) {\n            // construct a single-bit mask from the numerical value of the next byte of the array\n            bitMask = uint256(1 << uint8(orderedBytesArray[i]));\n            // check strictly ascending array ordering by comparing the mask to the bitmap so far (revert if mask isn't greater than bitmap)\n            require(bitMask > bitmap, \"BytesArrayBitmaps.orderedBytesArrayToBitmap: orderedBytesArray is not ordered\");\n            // add the entry to the bitmap\n            bitmap = (bitmap | bitMask);\n        }\n        return bitmap;\n    }\n\n    /**\n     * @notice Converts an ordered array of bytes into a bitmap. Optimized, Yul-heavy version of `orderedBytesArrayToBitmap`.\n     * @param orderedBytesArray The array of bytes to convert/compress into a bitmap. Must be in strictly ascending order.\n     * @return The resulting bitmap.\n     * @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap.\n     * @dev This function will eventually revert in the event that the `orderedBytesArray` is not properly ordered (in ascending order).\n     * @dev This function will also revert if the `orderedBytesArray` input contains any duplicate entries (i.e. duplicate bytes).\n     */\n    function orderedBytesArrayToBitmap_Yul(bytes calldata orderedBytesArray) internal pure returns (uint256) {\n        // sanity-check on input. a too-long input would fail later on due to having duplicate entry(s)\n        require(orderedBytesArray.length <= MAX_BYTE_ARRAY_LENGTH,\n            \"BytesArrayBitmaps.orderedBytesArrayToBitmap: orderedBytesArray is too long\");\n\n        // return empty bitmap early if length of array is 0\n        if (orderedBytesArray.length == 0) {\n            return uint256(0);\n        }\n\n        assembly {\n            // get first entry in bitmap (single byte => single-bit mask)\n            let bitmap :=\n                shl(\n                    // extract single byte to get the correct value for the left shift\n                    shr(\n                        248,\n                        calldataload(\n                            orderedBytesArray.offset\n                        )\n                    ),\n                    1\n                )\n            // loop through other entries (byte by byte)\n            for { let i := 1 } lt(i, orderedBytesArray.length) { i := add(i, 1) } {\n                // first construct the single-bit mask by left-shifting a '1'\n                let bitMask := \n                    shl(\n                        // extract single byte to get the correct value for the left shift\n                        shr(\n                            248,\n                            calldataload(\n                                add(\n                                    orderedBytesArray.offset,\n                                    i\n                                )\n                            )\n                        ),\n                        1\n                    )\n                // check strictly ascending ordering by comparing the mask to the bitmap so far (revert if mask isn't greater than bitmap)\n                // TODO: revert with a good message instead of using `revert(0, 0)`\n                // REFERENCE: require(bitMask > bitmap, \"BytesArrayBitmaps.orderedBytesArrayToBitmap: orderedBytesArray is not ordered\");\n                if iszero(gt(bitMask, bitmap)) { revert(0, 0) }\n                // update the bitmap by adding the single bit in the mask\n                bitmap := or(bitmap, bitMask)\n            }\n            // after the loop is complete, store the bitmap at the value encoded at the free memory pointer, then return it\n            mstore(mload(0x40), bitmap)\n            return(mload(0x40), 32)\n        }\n    }\n\n    /**\n     * @notice Converts an array of bytes into a bitmap. Optimized, Yul-heavy version of `bytesArrayToBitmap`.\n     * @param bytesArray The array of bytes to convert/compress into a bitmap.\n     * @return The resulting bitmap.\n     * @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap.\n     * @dev This function will eventually revert in the event that the `bytesArray` is not properly ordered (in ascending order).\n     * @dev This function will also revert if the `bytesArray` input contains any duplicate entries (i.e. duplicate bytes).\n     */\n    function bytesArrayToBitmap_Yul(bytes calldata bytesArray) internal pure returns (uint256) {\n        // sanity-check on input. a too-long input would fail later on due to having duplicate entry(s)\n        require(bytesArray.length <= MAX_BYTE_ARRAY_LENGTH,\n            \"BytesArrayBitmaps.bytesArrayToBitmap: bytesArray is too long\");\n\n        // return empty bitmap early if length of array is 0\n        if (bytesArray.length == 0) {\n            return uint256(0);\n        }\n\n        assembly {\n            // get first entry in bitmap (single byte => single-bit mask)\n            let bitmap :=\n                shl(\n                    // extract single byte to get the correct value for the left shift\n                    shr(\n                        248,\n                        calldataload(\n                            bytesArray.offset\n                        )\n                    ),\n                    1\n                )\n            // loop through other entries (byte by byte)\n            for { let i := 1 } lt(i, bytesArray.length) { i := add(i, 1) } {\n                // first construct the single-bit mask by left-shifting a '1'\n                let bitMask := \n                    shl(\n                        // extract single byte to get the correct value for the left shift\n                        shr(\n                            248,\n                            calldataload(\n                                add(\n                                    bytesArray.offset,\n                                    i\n                                )\n                            )\n                        ),\n                        1\n                    )\n                // check against duplicates by comparing the bitmask and bitmap (revert if the bitmap already contains the entry, i.e. bitmap & bitMask != 0)\n                // TODO: revert with a good message instead of using `revert(0, 0)`\n                // REFERENCE: require(bitmap & bitMask == 0, \"BytesArrayBitmaps.bytesArrayToBitmap: repeat entry in bytesArray\");\n                if gt(and(bitmap, bitMask), 0) { revert(0, 0) }\n                // update the bitmap by adding the single bit in the mask\n                bitmap := or(bitmap, bitMask)\n            }\n            // after the loop is complete, store the bitmap at the value encoded at the free memory pointer, then return it\n            mstore(mload(0x40), bitmap)\n            return(mload(0x40), 32)\n        }\n    }\n\n    /**\n     * @notice Utility function for checking if a bytes array is strictly ordered, in ascending order.\n     * @param bytesArray the bytes array of interest\n     * @return Returns 'true' if the array is ordered in strictly ascending order, and 'false' otherwise.\n     * @dev This function returns 'true' for the edge case of the `bytesArray` having zero length.\n     * It also returns 'false' early for arrays with length in excess of MAX_BYTE_ARRAY_LENGTH (i.e. so long that they cannot be strictly ordered)\n     */\n    function isArrayStrictlyAscendingOrdered(bytes calldata bytesArray) internal pure returns (bool) {\n        // return 'false' early for too-long (i.e. unorderable) arrays\n        if (bytesArray.length > MAX_BYTE_ARRAY_LENGTH) {\n            return false;\n        }\n\n        // return 'true' early if length of array is 0\n        if (bytesArray.length == 0) {\n            return true;\n        }\n\n        // initialize an empty byte object, to be re-used inside the loop\n        bytes1 singleByte;\n\n        // perform the 0-th loop iteration with the ordering check *omitted* (otherwise it will break with an out-of-bounds error)\n        // pull the 0th byte out of the array\n        singleByte = bytesArray[0];\n\n        // loop through each byte in the array to construct the bitmap\n        for (uint256 i = 1; i < bytesArray.length; ++i) {\n            // check if the entry is *less than or equal to* the previous entry. if it is, then the array isn't strictly ordered!\n            if (uint256(uint8(bytesArray[i])) <= uint256(uint8(singleByte))) {\n                return false;\n            }\n            // pull the next byte out of the array\n            singleByte = bytesArray[i];\n        }\n        return true;\n    }\n\n    /**\n     * @notice Converts a bitmap into an array of bytes.\n     * @param bitmap The bitmap to decompress/convert to an array of bytes.\n     * @return bytesArray The resulting bitmap array of bytes.\n     * @dev Each byte in the input is processed as indicating a single bit to flip in the bitmap\n     */\n    function bitmapToBytesArray(uint256 bitmap) internal pure returns (bytes memory bytesArray) {\n        // initialize an empty uint256 to be used as a bitmask inside the loop\n        uint256 bitMask;\n        // loop through each index in the bitmap to construct the array\n        for (uint256 i = 0; i < 256; ++i) {\n            // construct a single-bit mask for the i-th bit\n            bitMask = uint256(1 << i);\n            // check if the i-th bit is flipped in the bitmap\n            if (bitmap & bitMask != 0) {\n                // if the i-th bit is flipped, then add a byte encoding the value 'i' to the `bytesArray`\n                bytesArray = bytes.concat(bytesArray, bytes1(uint8(i)));\n            }\n        }\n        return bytesArray;\n    }\n}\n"
    },
    "contracts/EigenLayer/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for { let cc := add(_postBytes, 0x20) } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } { mstore(mc, mload(cc)) }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                // solhint-disable-next-line no-unused-vars\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } { sstore(sc, mload(mc)) }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } { mstore(mc, mload(cc)) }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for { let cc := add(_postBytes, 0x20) }\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        // solhint-disable-next-line no-empty-blocks\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "contracts/EigenLayer/libraries/Endian.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity =0.8.19;\n\nlibrary Endian {\n    /**\n     * @notice Converts a little endian-formatted uint64 to a big endian-formatted uint64\n     * @param lenum little endian-formatted uint64 input, provided as 'bytes32' type\n     * @return n The big endian-formatted uint64\n     * @dev Note that the input is formatted as a 'bytes32' type (i.e. 256 bits), but it is immediately truncated to a uint64 (i.e. 64 bits)\n     * through a right-shift/shr operation.\n     */\n    function fromLittleEndianUint64(\n        bytes32 lenum\n    ) internal pure returns (uint64 n) {\n        // the number needs to be stored in little-endian encoding (ie in bytes 0-8)\n        n = uint64(uint256(lenum >> 192));\n        return\n            (n >> 56) |\n            ((0x00FF000000000000 & n) >> 40) |\n            ((0x0000FF0000000000 & n) >> 24) |\n            ((0x000000FF00000000 & n) >> 8) |\n            ((0x00000000FF000000 & n) << 8) |\n            ((0x0000000000FF0000 & n) << 24) |\n            ((0x000000000000FF00 & n) << 40) |\n            ((0x00000000000000FF & n) << 56);\n    }\n}\n"
    },
    "contracts/EigenLayer/libraries/Merkle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Adapted from OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity =0.8.19;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary Merkle {\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function verifyInclusionKeccak(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal pure returns (bool) {\n        return processInclusionProofKeccak(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the keccak/sha3 hash function\n     */\n    function processInclusionProofKeccak(bytes memory proof, bytes32 leaf, uint256 index) internal pure returns (bytes32) {\n        require(proof.length != 0 && proof.length % 32 == 0, \"Merkle.processInclusionProofKeccak: proof length should be a non-zero multiple of 32\");\n        bytes32 computedHash = leaf;\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, computedHash)\n                    mstore(0x20, mload(add(proof, i)))\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, computedHash)\n                    computedHash := keccak256(0x00, 0x40)\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function verifyInclusionSha256(\n        bytes memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        uint256 index\n    ) internal view returns (bool) {\n        return processInclusionProofSha256(proof, leaf, index) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. The tree is built assuming `leaf` is \n     * the 0 indexed `index`'th leaf from the bottom left of the tree.\n     *\n     * _Available since v4.4._\n     * \n     * Note this is for a Merkle tree using the sha256 hash function\n     */\n    function processInclusionProofSha256(bytes memory proof, bytes32 leaf, uint256 index) internal view returns (bytes32) {\n        require(proof.length != 0 && proof.length % 32 == 0, \"Merkle.processInclusionProofSha256: proof length should be a non-zero multiple of 32\");\n        bytes32[1] memory computedHash = [leaf];\n        for (uint256 i = 32; i <= proof.length; i+=32) {\n            if(index % 2 == 0) {\n                // if ith bit of index is 0, then computedHash is a left sibling\n                assembly {\n                    mstore(0x00, mload(computedHash))\n                    mstore(0x20, mload(add(proof, i)))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }\n            } else {\n                // if ith bit of index is 1, then computedHash is a right sibling\n                assembly {\n                    mstore(0x00, mload(add(proof, i)))\n                    mstore(0x20, mload(computedHash))\n                    if iszero(staticcall(sub(gas(), 2000), 2, 0x00, 0x40, computedHash, 0x20)) {revert(0, 0)}\n                    index := div(index, 2)\n                }            \n            }\n        }\n        return computedHash[0];\n    }\n\n    /**\n     @notice this function returns the merkle root of a tree created from a set of leaves using sha256 as its hash function\n     @param leaves the leaves of the merkle tree\n     @return The computed Merkle root of the tree.\n     @dev A pre-condition to this function is that leaves.length is a power of two.  If not, the function will merkleize the inputs incorrectly.\n     */ \n    function merkleizeSha256(\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32) {\n        //there are half as many nodes in the layer above the leaves\n        uint256 numNodesInLayer = leaves.length / 2;\n        //create a layer to store the internal nodes\n        bytes32[] memory layer = new bytes32[](numNodesInLayer);\n        //fill the layer with the pairwise hashes of the leaves\n        for (uint i = 0; i < numNodesInLayer; i++) {\n            layer[i] = sha256(abi.encodePacked(leaves[2*i], leaves[2*i+1]));\n        }\n        //the next layer above has half as many nodes\n        numNodesInLayer /= 2;\n        //while we haven't computed the root\n        while (numNodesInLayer != 0) {\n            //overwrite the first numNodesInLayer nodes in layer with the pairwise hashes of their children\n            for (uint i = 0; i < numNodesInLayer; i++) {\n                layer[i] = sha256(abi.encodePacked(layer[2*i], layer[2*i+1]));\n            }\n            //the next layer above has half as many nodes\n            numNodesInLayer /= 2;\n        }\n        //the first node in the layer is the root\n        return layer[0];\n    }\n}"
    },
    "contracts/EigenLayer/libraries/MiddlewareUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.19;\n\n/**\n * @title Library of functions shared across DataLayr.\n * @author Layr Labs, Inc.\n * @notice Terms of Service: https://docs.eigenlayer.xyz/overview/terms-of-service\n */\nlibrary MiddlewareUtils {\n    /// @notice Finds the `signatoryRecordHash`, used for fraudproofs.\n    function computeSignatoryRecordHash(\n        uint32 globalDataStoreId,\n        bytes32[] memory nonSignerPubkeyHashes,\n        uint256 signedStakeFirstQuorum,\n        uint256 signedStakeSecondQuorum\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(globalDataStoreId, nonSignerPubkeyHashes, signedStakeFirstQuorum, signedStakeSecondQuorum)\n        );\n    }\n}\n"
    },
    "contracts/EigenLayer/libraries/StructuredLinkedList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity =0.8.19;\n\n/**\n * @title StructuredLinkedList\n * @author Vittorio Minacori (https://github.com/vittominacori)\n * @dev An utility library for using sorted linked list data structures in your Solidity project.\n * @notice Adapted from https://github.com/vittominacori/solidity-linked-list/blob/master/contracts/StructuredLinkedList.sol\n */\nlibrary StructuredLinkedList {\n    uint256 private constant _NULL = 0;\n    uint256 private constant _HEAD = 0;\n\n    bool private constant _PREV = false;\n    bool private constant _NEXT = true;\n\n    struct List {\n        uint256 size;\n        mapping(uint256 => mapping(bool => uint256)) list;\n    }\n\n    /**\n     * @dev Checks if the list exists\n     * @param self stored linked list from contract\n     * @return bool true if list exists, false otherwise\n     */\n    function listExists(List storage self) internal view returns (bool) {\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\n        if (self.list[_HEAD][_PREV] != _HEAD || self.list[_HEAD][_NEXT] != _HEAD) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Checks if the node exists\n     * @param self stored linked list from contract\n     * @param _node a node to search for\n     * @return bool true if node exists, false otherwise\n     */\n    function nodeExists(List storage self, uint256 _node) internal view returns (bool) {\n        if (self.list[_node][_PREV] == _HEAD && self.list[_node][_NEXT] == _HEAD) {\n            if (self.list[_HEAD][_NEXT] == _node) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Returns the number of elements in the list\n     * @param self stored linked list from contract\n     * @return uint256\n     */\n    function sizeOf(List storage self) internal view returns (uint256) {\n        return self.size;\n    }\n\n    /**\n     * @dev Gets the head of the list\n     * @param self stored linked list from contract\n     * @return uint256 the head of the list\n     */\n    function getHead(List storage self) internal view returns (uint256) {\n        return self.list[_HEAD][_NEXT];\n    }\n\n    /**\n     * @dev Returns the links of a node as a tuple\n     * @param self stored linked list from contract\n     * @param _node id of the node to get\n     * @return bool, uint256, uint256 true if node exists or false otherwise, previous node, next node\n     */\n    function getNode(List storage self, uint256 _node) internal view returns (bool, uint256, uint256) {\n        if (!nodeExists(self, _node)) {\n            return (false, 0, 0);\n        } else {\n            return (true, self.list[_node][_PREV], self.list[_node][_NEXT]);\n        }\n    }\n\n    /**\n     * @dev Returns the link of a node `_node` in direction `_direction`.\n     * @param self stored linked list from contract\n     * @param _node id of the node to step from\n     * @param _direction direction to step in\n     * @return bool, uint256 true if node exists or false otherwise, node in _direction\n     */\n    function getAdjacent(List storage self, uint256 _node, bool _direction) internal view returns (bool, uint256) {\n        if (!nodeExists(self, _node)) {\n            return (false, 0);\n        } else {\n            uint256 adjacent = self.list[_node][_direction];\n            return (adjacent != _HEAD, adjacent);\n        }\n    }\n\n    /**\n     * @dev Returns the link of a node `_node` in direction `_NEXT`.\n     * @param self stored linked list from contract\n     * @param _node id of the node to step from\n     * @return bool, uint256 true if node exists or false otherwise, next node\n     */\n    function getNextNode(List storage self, uint256 _node) internal view returns (bool, uint256) {\n        return getAdjacent(self, _node, _NEXT);\n    }\n\n    /**\n     * @dev Returns the link of a node `_node` in direction `_PREV`.\n     * @param self stored linked list from contract\n     * @param _node id of the node to step from\n     * @return bool, uint256 true if node exists or false otherwise, previous node\n     */\n    function getPreviousNode(List storage self, uint256 _node) internal view returns (bool, uint256) {\n        return getAdjacent(self, _node, _PREV);\n    }\n\n    /**\n     * @dev Insert node `_new` beside existing node `_node` in direction `_NEXT`.\n     * @param self stored linked list from contract\n     * @param _node existing node\n     * @param _new  new node to insert\n     * @return bool true if success, false otherwise\n     */\n    function insertAfter(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\n        return _insert(self, _node, _new, _NEXT);\n    }\n\n    /**\n     * @dev Insert node `_new` beside existing node `_node` in direction `_PREV`.\n     * @param self stored linked list from contract\n     * @param _node existing node\n     * @param _new  new node to insert\n     * @return bool true if success, false otherwise\n     */\n    function insertBefore(List storage self, uint256 _node, uint256 _new) internal returns (bool) {\n        return _insert(self, _node, _new, _PREV);\n    }\n\n    /**\n     * @dev Removes an entry from the linked list\n     * @param self stored linked list from contract\n     * @param _node node to remove from the list\n     * @return uint256 the removed node\n     */\n    function remove(List storage self, uint256 _node) internal returns (uint256) {\n        if ((_node == _NULL) || (!nodeExists(self, _node))) {\n            return 0;\n        }\n        _createLink(self, self.list[_node][_PREV], self.list[_node][_NEXT], _NEXT);\n        delete self.list[_node][_PREV];\n        delete self.list[_node][_NEXT];\n\n        self.size -= 1; // NOT: SafeMath library should be used here to decrement.\n\n        return _node;\n    }\n\n    /**\n     * @dev Pushes an entry to the head of the linked list\n     * @param self stored linked list from contract\n     * @param _node new entry to push to the head\n     * @return bool true if success, false otherwise\n     */\n    function pushFront(List storage self, uint256 _node) internal returns (bool) {\n        return _push(self, _node, _NEXT);\n    }\n\n    /**\n     * @dev Pushes an entry to the tail of the linked list\n     * @param self stored linked list from contract\n     * @param _node new entry to push to the tail\n     * @return bool true if success, false otherwise\n     */\n    function pushBack(List storage self, uint256 _node) internal returns (bool) {\n        return _push(self, _node, _PREV);\n    }\n\n    /**\n     * @dev Pops the first entry from the head of the linked list\n     * @param self stored linked list from contract\n     * @return uint256 the removed node\n     */\n    function popFront(List storage self) internal returns (uint256) {\n        return _pop(self, _NEXT);\n    }\n\n    /**\n     * @dev Pops the first entry from the tail of the linked list\n     * @param self stored linked list from contract\n     * @return uint256 the removed node\n     */\n    function popBack(List storage self) internal returns (uint256) {\n        return _pop(self, _PREV);\n    }\n\n    /**\n     * @dev Pushes an entry to the head of the linked list\n     * @param self stored linked list from contract\n     * @param _node new entry to push to the head\n     * @param _direction push to the head (_NEXT) or tail (_PREV)\n     * @return bool true if success, false otherwise\n     */\n    function _push(List storage self, uint256 _node, bool _direction) private returns (bool) {\n        return _insert(self, _HEAD, _node, _direction);\n    }\n\n    /**\n     * @dev Pops the first entry from the linked list\n     * @param self stored linked list from contract\n     * @param _direction pop from the head (_NEXT) or the tail (_PREV)\n     * @return uint256 the removed node\n     */\n    function _pop(List storage self, bool _direction) private returns (uint256) {\n        uint256 adj;\n        (, adj) = getAdjacent(self, _HEAD, _direction);\n        return remove(self, adj);\n    }\n\n    /**\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\n     * @param self stored linked list from contract\n     * @param _node existing node\n     * @param _new  new node to insert\n     * @param _direction direction to insert node in\n     * @return bool true if success, false otherwise\n     */\n    function _insert(List storage self, uint256 _node, uint256 _new, bool _direction) private returns (bool) {\n        if (!nodeExists(self, _new) && nodeExists(self, _node)) {\n            uint256 c = self.list[_node][_direction];\n            _createLink(self, _node, _new, _direction);\n            _createLink(self, _new, c, _direction);\n\n            self.size += 1; // NOT: SafeMath library should be used here to increment.\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\n     * @param self stored linked list from contract\n     * @param _node existing node\n     * @param _link node to link to in the _direction\n     * @param _direction direction to insert node in\n     */\n    function _createLink(List storage self, uint256 _node, uint256 _link, bool _direction) private {\n        self.list[_link][!_direction] = _node;\n        self.list[_node][_direction] = _link;\n    }\n}"
    },
    "contracts/Errors/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\n/// @dev Error for 0x0 address inputs\nerror InvalidZeroInput();    \n\n/// @dev Error for already added items to a list\nerror AlreadyAdded();    \n\n/// @dev Error for not found items in a list\nerror NotFound();    \n\n/// @dev Error for hitting max TVL\nerror MaxTVLReached();\n\n/// @dev Error for caller not having permissions\nerror NotRestakeManagerAdmin();\n\n/// @dev Error for call not coming from deposit queue contract\nerror NotDepositQueue();\n\n/// @dev Error for contract being paused\nerror ContractPaused(); \n\n/// @dev Error for exceeding max basis points (100%)\nerror OverMaxBasisPoints();\n\n/// @dev Error for invalid token decimals for collateral tokens (must be 18)\nerror InvalidTokenDecimals(uint8 expected, uint8 actual);\n\n/// @dev Error when withdraw is already completed\nerror WithdrawAlreadyCompleted();\n\n/// @dev Error when a different address tries to complete withdraw\nerror NotOriginalWithdrawCaller(address expectedCaller);\n\n/// @dev Error when caller does not have OD admin role\nerror NotOperatorDelegatorAdmin();\n\n/// @dev Error when caller does not have Oracle Admin role\nerror NotOracleAdmin();\n\n/// @dev Error when caller is not RestakeManager contract\nerror NotRestakeManager();\n\n/// @dev Errror when caller does not have ETH Restake Admin role\nerror NotNativeEthRestakeAdmin();\n\n/// @dev Error when delegation address was already set - cannot be set again\nerror DelegateAddressAlreadySet();\n\n/// @dev Error when caller does not have ERC20 Rewards Admin role\nerror NotERC20RewardsAdmin();\n\n/// @dev Error when ending ETH fails\nerror TransferFailed();\n\n/// @dev Error when caller does not have ETH Minter Burner Admin role\nerror NotEzETHMinterBurner();\n\n/// @dev Error when caller does not have Token Admin role\nerror NotTokenAdmin();\n\n/// @dev Error when price oracle is not configured\nerror OracleNotFound();\n\n/// @dev Error when price oracle data is stale\nerror OraclePriceExpired();\n\n/// @dev Error when array lengths do not match\nerror MismatchedArrayLengths();\n\n/// @dev Error when caller does not have Deposit Withdraw Pauser role\nerror NotDepositWithdrawPauser();"
    },
    "contracts/IRestakeManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./Delegation/IOperatorDelegator.sol\";\n\ninterface IRestakeManager {\n  function stakeEthInOperatorDelegator(IOperatorDelegator operatorDelegator, bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable;\n  function depositTokenRewardsFromProtocol(\n        IERC20 _token,\n        uint256 _amount\n    ) external;\n}\n"
    },
    "contracts/Oracle/IRenzoOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRenzoOracle {        \n    function lookupTokenValue(IERC20 _token, uint256 _balance) external view returns (uint256);\n    function lookupTokenAmountFromValue(IERC20 _token, uint256 _value) external view returns (uint256);\n    function lookupTokenValues(IERC20[] memory _tokens, uint256[] memory _balances) external view returns (uint256);\n    function calculateMintAmount(uint256 _currentValueInProtocol, uint256 _newValueAdded, uint256 _existingEzETHSupply) external pure returns (uint256);\n    function calculateRedeemAmount(uint256 _ezETHBeingBurned, uint256 _existingEzETHSupply, uint256 _currentValueInProtocol) external pure returns (uint256) ;\n}"
    },
    "contracts/Oracle/RenzoOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../Permissions/IRoleManager.sol\";\nimport \"./RenzoOracleStorage.sol\";\nimport \"./IRenzoOracle.sol\";\nimport \"../Errors/Errors.sol\";\n\n/// @dev This contract will be responsible for looking up values via Chainlink\n/// Data retrieved will be verified for liveness via a max age on the oracle lookup.\n/// All tokens should be denominated in the same base currency and contain the same decimals on the price lookup.\ncontract RenzoOracle is\n    IRenzoOracle,\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    RenzoOracleStorageV1\n{\n    /// @dev Error for invalid 0x0 address\n    string constant INVALID_0_INPUT = \"Invalid 0 input\";\n\n    // Scale factor for all values of prices\n    uint256 constant SCALE_FACTOR = 10 ** 18;\n\n    /// @dev The maxmimum staleness allowed for a price feed from chainlink\n    uint256 constant MAX_TIME_WINDOW = 86400 + 60; // 24 hours + 60 seconds\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyOracleAdmin() {\n        if(!roleManager.isOracleAdmin(msg.sender)) revert NotOracleAdmin();\n        _;\n    }\n\n    /// @dev Event emitted when a token's oracle address is updated\n    event OracleAddressUpdated(IERC20 token, AggregatorV3Interface oracleAddress);\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(IRoleManager _roleManager) public initializer {\n        if(address(_roleManager) == address(0x0)) revert InvalidZeroInput();\n\n        __ReentrancyGuard_init();     \n        \n        roleManager = _roleManager;   \n    }\n\n    /// @dev Sets addresses for oracle lookup.  Permission gated to oracel admins only.\n    /// Set to address 0x0 to disable lookups for the token.\n    function setOracleAddress(IERC20 _token, AggregatorV3Interface _oracleAddress) external nonReentrant onlyOracleAdmin { \n        if(address(_token) == address(0x0)) revert InvalidZeroInput();\n\n        // Verify that the pricing of the oracle is 18 decimals - pricing calculations will be off otherwise\n        if(_oracleAddress.decimals() != 18) revert InvalidTokenDecimals(18, _oracleAddress.decimals());\n\n        tokenOracleLookup[_token] = _oracleAddress;\n        emit OracleAddressUpdated(_token, _oracleAddress);\n    }\n\n    /// @dev Given a single token and balance, return value of the asset in underlying currency\n    /// The value returned will be denominated in the decimal precision of the lookup oracle\n    /// (e.g. a value of 100 would return as 100 * 10^18)\n    function lookupTokenValue(IERC20 _token, uint256 _balance) public view returns (uint256) {           \n        AggregatorV3Interface oracle = tokenOracleLookup[_token];\n        if(address(oracle) == address(0x0)) revert OracleNotFound();\n\n        (, int256 price, , uint256 timestamp, ) = oracle.latestRoundData();\n        if(timestamp < block.timestamp - MAX_TIME_WINDOW) revert OraclePriceExpired();\n\n        // Price is times 10**18 ensure value amount is scaled\n        return uint256(price) * _balance / SCALE_FACTOR;\n    }\n\n    /// @dev Given a single token and value, return amount of tokens needed to represent that value\n    /// Assumes the token value is already denominated in the same decimal precision as the oracle\n    function lookupTokenAmountFromValue(IERC20 _token, uint256 _value) external view returns (uint256) {           \n        AggregatorV3Interface oracle = tokenOracleLookup[_token];\n        if(address(oracle) == address(0x0)) revert OracleNotFound();\n\n        (, int256 price, , uint256 timestamp, ) = oracle.latestRoundData();\n        if(timestamp < block.timestamp - MAX_TIME_WINDOW) revert OraclePriceExpired();\n\n        // Price is times 10**18 ensure token amount is scaled\n        return _value * SCALE_FACTOR / uint256(price);\n    }\n\n    // @dev Given list of tokens and balances, return total value (assumes all lookups are denomintated in same underlying currency)\n    /// The value returned will be denominated in the decimal precision of the lookup oracle\n    /// (e.g. a value of 100 would return as 100 * 10^18)\n    function lookupTokenValues(IERC20[] memory _tokens, uint256[] memory _balances) external view returns (uint256) {\n        if(_tokens.length != _balances.length) revert MismatchedArrayLengths();\n\n        uint256 totalValue = 0;\n        uint256 tokenLength = _tokens.length;\n        for (uint256 i = 0; i < tokenLength;) {\n            totalValue += lookupTokenValue(_tokens[i], _balances[i]);\n            unchecked{++i;}\n        }\n\n        return totalValue;\n    }\n    \n    /// @dev Given amount of current protocol value, new value being added, and supply of ezETH, determine amount to mint\n    /// Values should be denominated in the same underlying currency with the same decimal precision\n    function calculateMintAmount(uint256 _currentValueInProtocol, uint256 _newValueAdded, uint256 _existingEzETHSupply) external pure returns (uint256) {\n        // For first mint, just return the new value added.\n        // Checking both current value and existing supply to guard against gaming the initial mint\n        if (_currentValueInProtocol == 0 || _existingEzETHSupply == 0) {\n            return _newValueAdded; // value is priced in base units, so divide by scale factor\n        }\n        \n        // Calculate the percentage of value after the deposit \n        uint256 inflationPercentaage = SCALE_FACTOR * _newValueAdded / (_currentValueInProtocol + _newValueAdded);\n\n        // Calculate the new supply\n        uint256 newEzETHSupply = (_existingEzETHSupply * SCALE_FACTOR) / (SCALE_FACTOR - inflationPercentaage);\n\n        // Subtract the old supply from the new supply to get the amount to mint\n        return newEzETHSupply - _existingEzETHSupply;\n    }\n\n    // Given the amount of ezETH to burn, the supply of ezETH, and the total value in the protocol, determine amount of value to return to user    \n    function calculateRedeemAmount(uint256 _ezETHBeingBurned, uint256 _existingEzETHSupply, uint256 _currentValueInProtocol) external pure returns (uint256) {\n      // This is just returning the percentage of TVL that matches the percentage of ezETH being burned \n      return (_currentValueInProtocol * _ezETHBeingBurned) / _existingEzETHSupply;\n    }\n}"
    },
    "contracts/Oracle/RenzoOracleStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"../Permissions/IRoleManager.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract RenzoOracleStorageV1 {    \n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev The mapping of supported token addresses to their respective Chainlink oracle address\n    mapping(IERC20 => AggregatorV3Interface) public tokenOracleLookup;\n}\n"
    },
    "contracts/Permissions/IRoleManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IRoleManager {\n    /// @dev Determines if the specified address has permissions to manage RoleManager\n    /// @param potentialAddress Address to check\n    function isRoleManagerAdmin(address potentialAddress) external view returns (bool);\n\n    /// @dev Determines if the specified address has permission to mint or burn ezETH tokens\n    /// @param potentialAddress Address to check\n    function isEzETHMinterBurner(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to update config on the OperatorDelgator Contracts\n    /// @param potentialAddress Address to check\n    function isOperatorDelegatorAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to update config on the Oracle Contract config\n    /// @param potentialAddress Address to check\n    function isOracleAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to update config on the Restake Manager\n    /// @param potentialAddress Address to check\n    function isRestakeManagerAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n\n    /// @dev Determines if the specified address has permission to update config on the Token Contract\n    /// @param potentialAddress Address to check\n    function isTokenAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);\n    \n    /// @dev Determines if the specified address has permission to trigger restaking of native ETH\n    /// @param potentialAddress Address to check\n    function isNativeEthRestakeAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);        \n\n    /// @dev Determines if the specified address has permission to sweep and deposit ERC20 Rewards\n    /// @param potentialAddress Address to check\n    function isERC20RewardsAdmin(address potentialAddress)\n        external\n        view\n        returns (bool);        \n    \n    /// @dev Determines if the specified address has permission to pause deposits and withdraws\n    /// @param potentialAddress Address to check\n    function isDepositWithdrawPauser(address potentialAddress)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/Permissions/RoleManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"./IRoleManager.sol\";\nimport \"./RoleManagerStorage.sol\";\nimport \"../Errors/Errors.sol\";\n\n/// @title RoleManager\n/// @dev This contract will track the roles and permissions in the protocol\n/// Note: This contract is protected via a permissioned account set via the initializer.  Caution should\n/// be used as the owner could renounce the role leaving all future actions disabled.  Additionally,\n/// if a malicious account was able to obtain the role, they could use it to grant permissions to malicious accounts.\ncontract RoleManager is\n    IRoleManager,\n    AccessControlUpgradeable,\n    RoleManagerStorageV1\n{\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev initializer to call after deployment, can only be called once\n    function initialize(address roleManagerAdmin) public initializer {\n        if(address(roleManagerAdmin) == address(0x0)) revert InvalidZeroInput();\n\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, roleManagerAdmin);\n    }\n\n    /// @dev Determines if the specified address has permissions to manage RoleManager\n    /// @param potentialAddress Address to check\n    function isRoleManagerAdmin(address potentialAddress) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, potentialAddress);\n    }\n\n    /// @dev Determines if the specified address has permission to mint or burn ezETH tokens\n    /// @param potentialAddress Address to check\n    function isEzETHMinterBurner(address potentialAddress)\n        external\n        view\n        returns (bool)\n    {\n        return hasRole(RX_ETH_MINTER_BURNER, potentialAddress);\n    }\n\n    /// @dev Determines if the specified address has permission to update config on the OperatorDelgator Contracts\n    /// @param potentialAddress Address to check\n    function isOperatorDelegatorAdmin(address potentialAddress)\n        external\n        view\n        returns (bool){\n        return hasRole(OPERATOR_DELEGATOR_ADMIN, potentialAddress);\n    }\n\n    /// @dev Determines if the specified address has permission to update config on the Oracle Contract config\n    /// @param potentialAddress Address to check\n    function isOracleAdmin(address potentialAddress)\n        external\n        view\n        returns (bool){\n            return hasRole(ORACLE_ADMIN, potentialAddress);\n        }\n\n    /// @dev Determines if the specified address has permission to update config on the RestakeManager Contract config\n    /// @param potentialAddress Address to check\n    function isRestakeManagerAdmin(address potentialAddress)\n        external\n        view\n        returns (bool) {\n            return hasRole(RESTAKE_MANAGER_ADMIN, potentialAddress);\n        }\n\n    /// @dev Determines if the specified address has permission to update config on the Token Contract\n    /// @param potentialAddress Address to check\n    function isTokenAdmin(address potentialAddress)\n        external\n        view\n        returns (bool) {\n            return hasRole(TOKEN_ADMIN, potentialAddress);\n        }\n        \n    /// @dev Determines if the specified address has permission to trigger restaking of native ETH\n    /// @param potentialAddress Address to check\n    function isNativeEthRestakeAdmin(address potentialAddress)\n        external\n        view\n        returns (bool) {\n            return hasRole(NATIVE_ETH_RESTAKE_ADMIN, potentialAddress);\n        }\n\n    /// @dev Determines if the specified address has permission to sweep and deposit ERC20 Rewards\n    /// @param potentialAddress Address to check\n    function isERC20RewardsAdmin(address potentialAddress)\n        external\n        view\n        returns (bool){\n            return hasRole(ERC20_REWARD_ADMIN, potentialAddress);\n        }\n\n    /// @dev Determines if the specified address has permission to pause deposits and withdraws\n    /// @param potentialAddress Address to check\n    function isDepositWithdrawPauser(address potentialAddress)\n        external\n        view\n        returns (bool){\n            return hasRole(DEPOSIT_WITHDRAW_PAUSER, potentialAddress);\n        }\n        \n}\n"
    },
    "contracts/Permissions/RoleManagerStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @title RoleManagerStorage\n/// @dev This contract will hold all local variables for the RoleManager Contract\n/// When upgrading the protocol, inherit from this contract on the V2 version and change the\n/// StorageManager to inherit from the later version.  This ensures there are no storage layout\n/// corruptions when upgrading.\ncontract RoleManagerStorageV1 {\n    /// @dev role for granting capability to mint/burn ezETH\n    bytes32 public constant RX_ETH_MINTER_BURNER =\n        keccak256(\"RX_ETH_MINTER_BURNER\");\n\n    /// @dev role for granting capability to update config on the OperatorDelgator Contracts\n    bytes32 public constant OPERATOR_DELEGATOR_ADMIN =\n        keccak256(\"OPERATOR_DELEGATOR_ADMIN\");\n\n    /// @dev role for granting capability to update config on the Oracle Contract\n    bytes32 public constant ORACLE_ADMIN =\n        keccak256(\"ORACLE_ADMIN\");\n\n    /// @dev role for granting capability to update config on the Restake Manager\n    bytes32 public constant RESTAKE_MANAGER_ADMIN =\n        keccak256(\"RESTAKE_MANAGER_ADMIN\");\n\n    /// @dev role for granting capability to update config on the Token Contract\n    bytes32 public constant TOKEN_ADMIN =\n        keccak256(\"TOKEN_ADMIN\");\n\n    /// @dev role for granting capability to restake native ETH\n    bytes32 public constant NATIVE_ETH_RESTAKE_ADMIN =\n        keccak256(\"NATIVE_ETH_RESTAKE_ADMIN\");\n\n    /// @dev role for sweeping ERC20 Rewards\n    bytes32 public constant ERC20_REWARD_ADMIN =\n        keccak256(\"ERC20_REWARD_ADMIN\");\n\n    /// @dev role for pausing deposits and withdraws on RestakeManager\n    bytes32 public constant DEPOSIT_WITHDRAW_PAUSER =\n        keccak256(\"DEPOSIT_WITHDRAW_PAUSER\");\n}\n\n/// On the next version of the protocol, if new variables are added, put them in the below\n/// contract and use this as the inheritance chain.\n/**\ncontract RoleManagerStorageV2 is RoleManagerStorageV1 {\n  address newVariable;\n}\n */\n"
    },
    "contracts/RestakeManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"./RestakeManagerStorage.sol\";\nimport \"./EigenLayer/interfaces/IStrategy.sol\";\nimport \"./EigenLayer/interfaces/IStrategyManager.sol\";\nimport \"./EigenLayer/interfaces/IDelegationManager.sol\";\nimport \"./token/IEzEthToken.sol\";\nimport \"./IRestakeManager.sol\";\nimport \"./Errors/Errors.sol\";\n\n/**\n * @author  Renzo\n * @title   RestakeManager\n * @dev     This contract is the main entrypoint for external users into the protocol\n            Users will interact with this contract to deposit and withdraw value into and from EigenLayer\n            Ownership of deposited funds will be tracked via the ezETh token\n */\ncontract RestakeManager is\n    IRestakeManager,\n    Initializable,\n    ReentrancyGuardUpgradeable,\n    RestakeManagerStorageV1\n{\n    using SafeERC20 for IERC20;\n    using SafeERC20Upgradeable for IEzEthToken;\n\n    event OperatorDelegatorAdded(IOperatorDelegator od);\n    event OperatorDelegatorRemoved(IOperatorDelegator od);\n    event OperatorDelegatorAllocationUpdated(IOperatorDelegator od, uint256 allocation);\n\n    event CollateralTokenAdded(IERC20 token);\n    event CollateralTokenRemoved(IERC20 token);    \n\n    /// @dev Basis points used for percentages (100 basis points equals 1%)\n    uint256 constant BASIS_POINTS = 100;\n\n    /// @dev Event emitted when a new deposit occurs\n    event Deposit(\n        address depositor,\n        IERC20 token,\n        uint256 amount,\n        uint256 ezETHMinted\n    );\n\n    /// @dev Event emitted when a new withdraw is started\n    event UserWithdrawStarted(\n        bytes32 withdrawalRoot,\n        address withdrawer,\n        IERC20 token,\n        uint256 amount,\n        uint256 ezETHToBurn\n    );\n\n    /// @dev Event emitted when a new withdraw is completed\n    event UserWithdrawCompleted(\n        bytes32 withdrawalRoot,\n        address withdrawer,\n        IERC20 token,\n        uint256 amount,\n        uint256 ezETHBurned\n    );\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyRestakeManagerAdmin() {\n        if(!roleManager.isRestakeManagerAdmin(msg.sender)) revert NotRestakeManagerAdmin();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to set pause state\n    modifier onlyDepositWithdrawPauserAdmin() {\n        if(!roleManager.isDepositWithdrawPauser(msg.sender)) revert NotDepositWithdrawPauser();\n        _;\n    }\n\n    /// @dev Allows only the deposit queue to call functions\n    modifier onlyDepositQueue() {\n        if(msg.sender != address(depositQueue)) revert NotDepositQueue();\n        _;\n    }\n\n    /// @dev Only allows execution if contract is not paused\n    modifier notPaused() {\n        if(paused) revert ContractPaused();\n        _;\n    }\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(\n        IRoleManager _roleManager,\n        IEzEthToken _ezETH,\n        IRenzoOracle _renzoOracle,\n        IStrategyManager _strategyManager,\n        IDelegationManager _delegationManager,\n        IDepositQueue _depositQueue\n    ) public initializer {\n\n        __ReentrancyGuard_init();\n        \n        roleManager = _roleManager;\n        ezETH = _ezETH;\n        renzoOracle = _renzoOracle;\n        strategyManager = _strategyManager;\n        delegationManager = _delegationManager;\n        depositQueue = _depositQueue;\n        paused = false;\n    }\n\n    /// @dev Allows a restake manager admin to set the paused state of the contract\n    function setPaused(bool _paused) external onlyDepositWithdrawPauserAdmin {\n        paused = _paused;\n    }\n\n    /// @dev Get the length of the operator delegators array\n    function getOperatorDelegatorsLength() external view returns (uint256) {\n        return operatorDelegators.length;\n    }\n\n    /// @dev Allows a restake manager admin to add an OperatorDelegator to the list\n    function addOperatorDelegator(\n        IOperatorDelegator _newOperatorDelegator,\n        uint256 _allocationBasisPoints\n    ) external onlyRestakeManagerAdmin {\n        // Ensure it is not already in the list\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            if( address(operatorDelegators[i]) == address(_newOperatorDelegator)) revert AlreadyAdded();\n            unchecked{++i;}        \n        }\n\n        // Verify a valid allocation\n        if(_allocationBasisPoints > (100 * BASIS_POINTS)) revert OverMaxBasisPoints();\n\n        // Add it to the list\n        operatorDelegators.push(_newOperatorDelegator);\n\n        emit OperatorDelegatorAdded(_newOperatorDelegator);\n\n        // Set the allocation\n        operatorDelegatorAllocations[\n            _newOperatorDelegator\n        ] = _allocationBasisPoints;\n\n        emit OperatorDelegatorAllocationUpdated(\n            _newOperatorDelegator,\n            _allocationBasisPoints\n        );\n    }\n\n    /// @dev Allows a restake manager admin to remove an OperatorDelegator from the list\n    function removeOperatorDelegator(\n        IOperatorDelegator _operatorDelegatorToRemove\n    ) external onlyRestakeManagerAdmin {\n        // Remove it from the list\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            if (\n                address(operatorDelegators[i]) ==\n                address(_operatorDelegatorToRemove)\n            ) {\n                // Clear the allocation\n                operatorDelegatorAllocations[_operatorDelegatorToRemove] = 0;\n                emit OperatorDelegatorAllocationUpdated(\n                    _operatorDelegatorToRemove,\n                    0\n                );\n\n                // Remove from list\n                operatorDelegators[i] = operatorDelegators[\n                    operatorDelegators.length - 1\n                ];\n                operatorDelegators.pop();\n                emit OperatorDelegatorRemoved(_operatorDelegatorToRemove);\n                return;\n            }\n            unchecked{++i;}\n        }\n\n        // If the item was not found, throw an error\n        revert NotFound();\n    }\n\n    /// @dev Allows restake manager admin to set an OperatorDelegator allocation\n    function setOperatorDelegatorAllocation(\n        IOperatorDelegator _operatorDelegator,\n        uint256 _allocationBasisPoints\n    ) external onlyRestakeManagerAdmin {\n        if(address(_operatorDelegator) == address(0x0)) revert InvalidZeroInput();\n        if(_allocationBasisPoints > (100 * BASIS_POINTS)) revert OverMaxBasisPoints();\n\n        // Ensure the OD is in the list to prevent mis-configuration\n        bool foundOd = false;\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            if (\n                address(operatorDelegators[i]) ==\n                address(_operatorDelegator)\n            ) {\n                foundOd = true;\n                break;\n            }\n            unchecked{++i;}\n        }\n        if(!foundOd) revert NotFound();\n\n\n        // Set the allocation\n        operatorDelegatorAllocations[\n            _operatorDelegator\n        ] = _allocationBasisPoints;\n\n        emit OperatorDelegatorAllocationUpdated(\n            _operatorDelegator,\n            _allocationBasisPoints\n        );\n    }\n\n    /// @dev Allows a restake manager admin to set the max TVL for deposits.  If set to 0, no deposits will be enforced.\n    function setMaxDepositTVL(uint256 _maxDepositTVL) external onlyRestakeManagerAdmin {\n        maxDepositTVL = _maxDepositTVL;\n    }\n\n    /// @dev Allows restake manager to add a collateral token\n    function addCollateralToken(\n        IERC20 _newCollateralToken\n    ) external onlyRestakeManagerAdmin {\n        // Ensure it is not already in the list\n        uint256 tokenLength = collateralTokens.length;\n        for (uint256 i = 0; i < tokenLength;) {\n            if( address(collateralTokens[i]) == address(_newCollateralToken)) revert AlreadyAdded();\n            unchecked{++i;}\n        }\n\n        // Verify the token has 18 decimal precision - pricing calculations will be off otherwise\n        if(IERC20Metadata(address(_newCollateralToken)).decimals() != 18) revert InvalidTokenDecimals(18, IERC20Metadata(address(_newCollateralToken)).decimals());\n\n        // Add it to the list\n        collateralTokens.push(_newCollateralToken);\n\n        emit CollateralTokenAdded(_newCollateralToken);\n    }\n\n    /// @dev Allows restake manager to remove a collateral token\n    function removeCollateralToken(\n        IERC20 _collateralTokenToRemove\n    ) external onlyRestakeManagerAdmin {\n        // Remove it from the list\n        uint256 tokenLength = collateralTokens.length;\n        for (uint256 i = 0; i < tokenLength;) {\n            if (\n                address(collateralTokens[i]) ==\n                address(_collateralTokenToRemove)\n            ) {\n                collateralTokens[i] = collateralTokens[\n                    collateralTokens.length - 1\n                ];\n                collateralTokens.pop();\n                emit CollateralTokenRemoved(_collateralTokenToRemove);\n                return;\n            }\n            unchecked{++i;}\n        }\n\n        // If the item was not found, throw an error\n        revert NotFound();\n    }\n\n    /// @dev Get the length of the collateral tokens array\n    function getCollateralTokensLength() external view returns (uint256) {\n        return collateralTokens.length;\n    }\n\n    /// @dev This function calculates the TVLs for each operator delegator by individual token, total for each OD, and total for the protocol.\n    /// @return operatorDelegatorTokenTVLs Each OD's TVL indexed by operatorDelegators array by collateralTokens array\n    /// @return operatorDelegatorTVLs Each OD's Total TVL in order of operatorDelegators array\n    /// @return totalTVL The total TVL across all operator delegators.\n    function calculateTVLs()\n        public\n        view\n        returns (uint256[][] memory, uint256[] memory, uint256)\n    {\n        uint256[][] memory operatorDelegatorTokenTVLs = new uint256[][](\n            operatorDelegators.length\n        );\n        uint256[] memory operatorDelegatorTVLs = new uint256[](\n            operatorDelegators.length\n        );\n        uint256 totalTVL = 0;\n\n        // Iterate through the ODs\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            // Track the TVL for this OD\n            uint256 operatorTVL = 0;\n\n            // Track the individual token TVLs for this OD - native ETH will be last item in the array\n            uint256[] memory operatorValues = new uint256[](\n                collateralTokens.length + 1\n            );\n            operatorDelegatorTokenTVLs[i] = operatorValues;\n\n            // Iterate through the tokens and get the value of each\n            uint256 tokenLength = collateralTokens.length;\n            for (uint256 j = 0; j < tokenLength;) {\n                // Get the value of this token\n                uint256 operatorBalance = operatorDelegators[i]\n                    .getTokenBalanceFromStrategy(collateralTokens[j]);\n\n                // Set the value in the array for this OD\n                operatorValues[j] = renzoOracle.lookupTokenValue(\n                    collateralTokens[j],\n                    operatorBalance\n                );\n\n                // Add it to the total TVL for this OD\n                operatorTVL += operatorValues[j];\n\n                unchecked{++j;}\n            }\n\n            // Get the value of native ETH staked for the OD\n            uint256 operatorEthBalance = operatorDelegators[i].getStakedETHBalance();\n\n            // Save it to the array for the OD\n            operatorValues[operatorValues.length - 1] = operatorEthBalance;\n\n            // Add it to the total TVL for this OD\n            operatorTVL += operatorEthBalance;\n\n            // Add it to the total TVL for the protocol\n            totalTVL += operatorTVL;\n\n            // Save the TVL for this OD\n            operatorDelegatorTVLs[i] = operatorTVL;\n\n            unchecked{++i;}\n        }\n\n        // Get the value of native ETH held in the deposit queue and add it to the total TVL\n        totalTVL += address(depositQueue).balance;\n\n        return (operatorDelegatorTokenTVLs, operatorDelegatorTVLs, totalTVL);\n    }\n\n    /// @dev Picks the OperatorDelegator with the TVL below the threshold or returns the first one in the list\n    /// @return The OperatorDelegator to use\n    function chooseOperatorDelegatorForDeposit(\n        uint256[] memory tvls,\n        uint256 totalTVL\n    ) public view returns (IOperatorDelegator) {\n        // Ensure OperatorDelegator list is not empty\n        if (operatorDelegators.length == 0) revert NotFound();\n\n        // If there is only one operator delegator, return it\n        if (operatorDelegators.length == 1) {\n            return operatorDelegators[0];\n        }\n\n        // Otherwise, find the operator delegator with TVL below the threshold\n        uint256 tvlLength = tvls.length;\n        for (uint256 i = 0; i < tvlLength;) {\n            if (\n                tvls[i] <\n                (operatorDelegatorAllocations[operatorDelegators[i]] *\n                    totalTVL) /\n                    BASIS_POINTS /\n                    BASIS_POINTS\n            ) {\n                return operatorDelegators[i];\n            }\n\n            unchecked{++i;}\n        }\n\n        // Default to the first operator delegator\n        return operatorDelegators[0];\n    }\n\n    /// @dev Determines the OD to withdraw from\n    /// It will try to use the OD with the TVL above the allocation threshold that has the tokens to withdraw\n    /// If no OD is over the allocation and has tokens, it will try to find one that has the tokens to withdraw\n    /// If no OD has the tokens to withdraw, it will revert\n    /// @return The OperatorDelegator to use\n    function chooseOperatorDelegatorForWithdraw(\n        uint256 tokenIndex,\n        uint256 ezETHValue,\n        uint256[][] memory operatorDelegatorTokenTVLs,\n        uint256[] memory operatorDelegatorTVLs,\n        uint256 totalTVL\n    ) public view returns (IOperatorDelegator) {\n        // If there is only one operator delegator, try to use it\n        if (operatorDelegators.length == 1) {\n            // If the OD doesn't have the tokens, revert\n            if (operatorDelegatorTokenTVLs[0][tokenIndex] < ezETHValue) {\n                revert NotFound();\n            }\n            return operatorDelegators[0];\n        }\n\n        // Fnd the operator delegator with TVL above the threshold and with enough tokens\n        uint256 odLength = operatorDelegatorTVLs.length;\n        for (uint256 i = 0; i < odLength;) {\n            if (\n                operatorDelegatorTVLs[i] >\n                (operatorDelegatorAllocations[operatorDelegators[i]] *\n                    totalTVL) /\n                    BASIS_POINTS /\n                    BASIS_POINTS &&\n                operatorDelegatorTokenTVLs[i][tokenIndex] >= ezETHValue\n            ) {\n                return operatorDelegators[i];\n            }\n\n            unchecked{++i;}\n        }\n\n        // If not found, just find one with enough tokens        \n        for (uint256 i = 0; i < odLength;) {\n            if (operatorDelegatorTokenTVLs[i][tokenIndex] >= ezETHValue) {\n                return operatorDelegators[i];\n            }\n\n            unchecked{++i;}\n        }\n\n        // This token cannot be withdrawn\n        revert NotFound();\n    }\n\n    /// @dev Finds the index of the collateral token in the list\n    /// Reverts if the token is not found in the list\n    function getCollateralTokenIndex(\n        IERC20 _collateralToken\n    ) public view returns (uint256) {\n        // Find the token index\n        uint256 tokenLength = collateralTokens.length;\n        for (uint256 i = 0; i < tokenLength;) {\n            if (collateralTokens[i] == _collateralToken) {\n                return i;\n            }\n\n            unchecked{++i;}\n        }\n\n        revert NotFound();\n    }\n\n    /**\n     * @notice  Deposits an ERC20 collateral token into the protocol\n     * @dev\n     * The msg.sender must pre-approve this contract to move the tokens into the protocol\n     * To deposit, the contract will:\n     *   - Figure out which operator delegator to use\n     *   - Transfer the collateral token to the operator delegator and deposit it into EigenLayer\n     *   - Calculate and mint the appropriate amount of ezETH back to the user\n     * ezETH will get inflated proportional to the value they are depositing vs the value already in the protocol\n     * The collateral token specified must be pre-configured to be allowed in the protocol\n     * @param   _collateralToken  The address of the collateral ERC20 token to deposit\n     * @param   _amount The amount of the collateral token to deposit in base units\n     */\n    function deposit(\n        IERC20 _collateralToken,\n        uint256 _amount\n    ) external nonReentrant notPaused {\n        // Verify collateral token is in the list - call will revert if not found\n        getCollateralTokenIndex(_collateralToken);\n\n        // Get the TVLs for each operator delegator and the total TVL\n        (\n            ,\n            uint256[] memory operatorDelegatorTVLs,\n            uint256 totalTVL\n        ) = calculateTVLs();\n\n        // Get the value of the collateral token being deposited\n        uint256 collateralTokenValue = renzoOracle.lookupTokenValue(\n            _collateralToken,\n            _amount\n        );\n\n        // Enforce TVL limit if set\n        if(maxDepositTVL != 0 && totalTVL + collateralTokenValue > maxDepositTVL) {\n            revert MaxTVLReached();\n        }\n\n\n        // Determine which operator delegator to use\n        IOperatorDelegator operatorDelegator = chooseOperatorDelegatorForDeposit(\n                operatorDelegatorTVLs,\n                totalTVL\n            );\n\n        // Transfer the collateral token to this address\n        _collateralToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        // Approve the tokens to the operator delegator\n        _collateralToken.safeApprove(address(operatorDelegator), _amount);\n\n        // Call deposit on the operator delegator\n        operatorDelegator.deposit(_collateralToken, _amount);\n\n        // Calculate how much ezETH to mint\n        uint256 ezETHToMint = renzoOracle.calculateMintAmount(\n            totalTVL,\n            collateralTokenValue,\n            ezETH.totalSupply()\n        );\n\n        // Mint the ezETH\n        ezETH.mint(msg.sender, ezETHToMint);\n\n        // Emit the deposit event\n        emit Deposit(msg.sender, _collateralToken, _amount, ezETHToMint);\n    }\n\n    /// @dev \n\n    /**\n     * @notice  Starts a 2 phase withdraw of a collateral token from the protocol in exchange for ezETH\n     * @dev  The msg.sender must pre-approve this contract to move the ezETH into the protocol\n     * The amount of tokens the user is requesting must be available to withdraw from a single OperatorDelegator\n     * The OD will be chosen based on the weightings and current value held in each OD on Eigenlayer\n     * To complete the withdaw, the caller must call completeWithdraw after the withdraw period has passed\n     * The ezETH will be held in this contract until the withdraw is completed\n     * @param   _ezEThToBurn  The amount of ezETH to burn in base units\n     * @param   _tokenToWithdraw  The address of the collateral ERC20 token to withdraw\n     * @return  bytes32  The withdrawal root of the EigenLayer deposit\n     */\n    function startWithdraw(\n        uint256 _ezEThToBurn,\n        IERC20 _tokenToWithdraw\n    ) external nonReentrant notPaused returns (bytes32) {\n        // Move the ezETH into this contract\n        ezETH.safeTransferFrom(msg.sender, address(this), _ezEThToBurn);\n\n        // Get the TVLs for each operator delegator and the total TVL\n        (\n            uint256[][] memory operatorDelegatorTokenTVLs,\n            uint256[] memory operatorDelegatorTVLs,\n            uint256 totalTVL\n        ) = calculateTVLs();\n\n        // Get the value of the ezETH being burned\n        uint256 ezETHValue = renzoOracle.calculateRedeemAmount(\n            _ezEThToBurn,\n            ezETH.totalSupply(),\n            totalTVL\n        );\n\n        // Find the token index\n        uint256 tokenIndex = getCollateralTokenIndex(_tokenToWithdraw);\n\n        // Choose the OD to withdraw from\n        IOperatorDelegator operatorDelegator = chooseOperatorDelegatorForWithdraw(\n                tokenIndex,\n                ezETHValue,\n                operatorDelegatorTokenTVLs,\n                operatorDelegatorTVLs,\n                totalTVL\n            );\n\n        // Get the number of tokens to withdraw from the value\n        uint256 numTokensToWithdraw = renzoOracle.lookupTokenAmountFromValue(\n            _tokenToWithdraw,\n            ezETHValue\n        );\n\n        // Start withdraw period\n        bytes32 withdrawalRoot = operatorDelegator.startWithdrawal(\n            _tokenToWithdraw,\n            numTokensToWithdraw\n        );\n\n        // Save off pending withdraw, including withdrawal root, how much ezETH to burn, and where to send the tokens on completion\n        pendingWithdrawals[withdrawalRoot] = PendingWithdrawal({\n            ezETHToBurn: _ezEThToBurn,\n            tokenToWithdraw: _tokenToWithdraw,\n            tokenAmountToWithdraw: numTokensToWithdraw,\n            withdrawer: msg.sender,\n            operatorDelegator: operatorDelegator,\n            completed: false\n        });\n\n        // Emit the withdraw started event\n        emit UserWithdrawStarted(\n            withdrawalRoot,\n            msg.sender,\n            _tokenToWithdraw,\n            numTokensToWithdraw,\n            _ezEThToBurn\n        );\n\n        return withdrawalRoot;\n    }\n\n    /// @dev \n    /// \n    /// @return The amount of tokens withdrawn\n    /**\n     * @notice  Completes a 2 phase withdraw of a collateral token from the protocol\n     * @dev     Caller must have called startWithdraw() and waited for the withdraw period to pass\n     * If the EigenLayer withdraw is completed, the tokens requested will be sent to the withdrawer\n     * The ezETH deposited in startWithdraw() will be burned from this contract\n     * @param   withdrawal  The data from startWithdraw()\n     * @param   middlewareTimesIndex  From EigenLayer - not used in M1 release (can be 0)\n     * @return  uint256  The amount of tokens withdrawn\n     */\n    function completeWithdraw(\n        IStrategyManager.QueuedWithdrawal calldata withdrawal,\n        uint256 middlewareTimesIndex\n    ) external nonReentrant notPaused returns (uint256) {\n        // Get the withdrawal root for the withdrawal\n        bytes32 withdrawalRoot = strategyManager.calculateWithdrawalRoot(\n            withdrawal\n        );\n\n        // Get and verify the pending withdraw\n        PendingWithdrawal memory pendingWithdrawal = pendingWithdrawals[\n            withdrawalRoot\n        ];\n        if(pendingWithdrawal.completed) revert WithdrawAlreadyCompleted();\n        if(pendingWithdrawal.withdrawer != msg.sender) revert NotOriginalWithdrawCaller(pendingWithdrawal.withdrawer);\n\n        // Complete the withdraw with the Operator Delegator\n        pendingWithdrawal.operatorDelegator.completeWithdrawal(\n            withdrawal,\n            pendingWithdrawal.tokenToWithdraw,\n            middlewareTimesIndex,\n            msg.sender\n        );\n\n        // Burn the ezETH from this contract\n        ezETH.burn(address(this), pendingWithdrawal.ezETHToBurn);\n\n        // Mark the pending withdraw as completed\n        pendingWithdrawals[withdrawalRoot].completed = true;\n\n        // Emit the withdraw completed event\n        emit UserWithdrawCompleted(\n            withdrawalRoot,\n            msg.sender,\n            pendingWithdrawal.tokenToWithdraw,\n            pendingWithdrawal.tokenAmountToWithdraw,\n            pendingWithdrawal.ezETHToBurn\n        );\n\n        return pendingWithdrawal.tokenAmountToWithdraw;\n    }\n\n    /**\n     * @notice  Allows a user to deposit ETH into the protocol and get back ezETH\n     * @dev     The amount of ETH sent into this function will be sent to the deposit queue to be \n     * staked later by a validator.  Once staked it will be deposited into EigenLayer.\n     */\n    function depositETH() external payable nonReentrant notPaused {\n        // Get the total TVL\n        (\n            ,\n            ,\n            uint256 totalTVL\n        ) = calculateTVLs();\n\n        // Enforce TVL limit if set\n        if(maxDepositTVL != 0 && totalTVL + msg.value > maxDepositTVL) {\n            revert MaxTVLReached();\n        }\n\n        // Deposit the ETH into the DepositQueue\n        depositQueue.depositETHFromProtocol{value: msg.value}();\n\n        // Calculate how much ezETH to mint\n        uint256 ezETHToMint = renzoOracle.calculateMintAmount(\n            totalTVL,\n            msg.value,\n            ezETH.totalSupply()\n        );\n\n        // Mint the ezETH\n        ezETH.mint(msg.sender, ezETHToMint);\n\n        // Emit the deposit event\n        emit Deposit(msg.sender, IERC20(address(0x0)), msg.value, ezETHToMint);\n    }\n\n    /// @dev Called by the deposit queue to stake ETH to a validator\n    /// Only callable by the deposit queue\n    function stakeEthInOperatorDelegator(IOperatorDelegator operatorDelegator, bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable onlyDepositQueue {\n        // Verify the OD is in the list\n        bool found = false;\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            if (operatorDelegators[i] == operatorDelegator) {\n                found = true;\n                break;\n            }\n\n            unchecked{++i;}\n        }\n        if(!found) revert NotFound();\n\n        // Call the OD to stake the ETH\n        operatorDelegator.stakeEth{value: msg.value}(pubkey, signature, depositDataRoot);\n    }\n\n    /// @dev Deposit ERC20 token rewards from the Deposit Queue\n    /// Only callable by the deposit queue\n    function depositTokenRewardsFromProtocol(\n        IERC20 _token,\n        uint256 _amount\n    ) external onlyDepositQueue {        \n        \n        // Get the TVLs for each operator delegator and the total TVL\n        (\n            ,\n            uint256[] memory operatorDelegatorTVLs,\n            uint256 totalTVL\n        ) = calculateTVLs();\n\n        // Determine which operator delegator to use\n        IOperatorDelegator operatorDelegator = chooseOperatorDelegatorForDeposit(\n                operatorDelegatorTVLs,\n                totalTVL\n            );\n\n        // Transfer the tokens to this address\n        _token.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n\n        // Approve the tokens to the operator delegator\n        _token.safeApprove(address(operatorDelegator), _amount);\n\n        // Deposit the tokens into EigenLayer\n        operatorDelegator.deposit(_token, _amount);\n    }\n\n    /**\n     * @notice  Returns the total amount of rewards earned by the protocol\n     * @dev     Rewards include staking native ETH and EigenLayer rewards (ETH + ERC20s)\n     * @return  uint256  The total amount of rewards earned by the protocol priced in ETH\n     */\n    function getTotalRewardsEarned() external view returns (uint256){\n        uint256 totalRewards = 0;\n\n        // First get the ETH rewards tracked in the deposit queue\n        totalRewards += depositQueue.totalEarned(address(0x0));\n\n        // For each token, get the total rewards earned from the deposit queue and price it in ETH\n        uint256 tokenLength = collateralTokens.length;\n        for (uint256 i = 0; i < tokenLength;) {    \n            // Get the amount        \n            uint256 tokenRewardAmount = depositQueue.totalEarned(address(collateralTokens[i]));\n\n            // Convert via the price oracle\n            totalRewards += renzoOracle.lookupTokenValue(collateralTokens[i], tokenRewardAmount);\n\n            unchecked{++i;}\n        }\n\n        // For each OperatorDelegator, get the balance (these are rewards from staking that have not been restaked)\n        uint256 odLength = operatorDelegators.length;\n        for (uint256 i = 0; i < odLength;) {\n            totalRewards += address(operatorDelegators[i].eigenPod()).balance;\n            unchecked{++i;}\n        }\n\n        return totalRewards;\n    }\n}\n"
    },
    "contracts/RestakeManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"./EigenLayer/interfaces/IStrategy.sol\";\nimport \"./EigenLayer/interfaces/IDelegationManager.sol\";\nimport \"./EigenLayer/interfaces/IStrategyManager.sol\";\nimport \"./token/IEzEthToken.sol\";\nimport \"./Delegation/IOperatorDelegator.sol\";\nimport \"./Permissions/IRoleManager.sol\";\nimport \"./Oracle/IRenzoOracle.sol\";\nimport \"./Deposits/IDepositQueue.sol\";\n\nabstract contract RestakeManagerStorageV1 {    \n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev reference to the ezETH token contract\n    IEzEthToken public ezETH;\n\n    /// @dev reference to the strategyManager contract in EigenLayer\n    IStrategyManager public strategyManager;\n\n    /// @dev reference to the delegationManager contract in EigenLayer\n    IDelegationManager public delegationManager;\n\n    /// @dev data stored for a withdrawal\n    struct PendingWithdrawal {\n        uint256 ezETHToBurn;\n        address withdrawer;\n        IERC20 tokenToWithdraw;\n        uint256 tokenAmountToWithdraw;\n        IOperatorDelegator operatorDelegator;\n        bool completed;\n    }\n\n    /// @dev mapping of pending withdrawals, indexed by the withdrawal root from EigenLayer\n    mapping(bytes32 => PendingWithdrawal) public pendingWithdrawals;   \n\n    /// @dev Stores the list of OperatorDelegators\n    IOperatorDelegator[] public operatorDelegators;\n\n    /// @dev Mapping to store the allocations to each operatorDelegator\n    /// Stored in basis points (e.g. 1% = 100)\n    mapping(IOperatorDelegator => uint256) public operatorDelegatorAllocations;\n\n    /// @dev Stores the list of collateral tokens\n    IERC20[] public collateralTokens;\n\n    /// @dev Reference to the oracle contract\n    IRenzoOracle public renzoOracle;\n\n    /// @dev Controls pause state of contract\n    bool public paused;\n\n    /// @dev The max amount of TVL allowed.  If this is set to 0, no max TVL is enforced\n    uint256 public maxDepositTVL;\n\n    /// @dev Reference to the deposit queue contract\n    IDepositQueue public depositQueue;\n}\n"
    },
    "contracts/Rewards/RewardHandler.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./RewardHandlerStorage.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../Errors/Errors.sol\";\n\n\n/**\n * @author  Renzo Protocol\n * @title   RewardHandler\n * @dev     Handles native ETH rewards deposited on the execution layer from validator nodes.  Forwards them\n * to the DepositQueue contract for restaking.\n * @notice  .\n */\ncontract RewardHandler is Initializable, ReentrancyGuardUpgradeable, RewardHandlerStorageV1 {\n\n    /// @dev Allows only a whitelisted address to trigger native ETH staking\n    modifier onlyNativeEthRestakeAdmin() {\n        if(!roleManager.isNativeEthRestakeAdmin(msg.sender)) revert NotNativeEthRestakeAdmin();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to configure the contract\n    modifier onlyRestakeManagerAdmin() {\n        if(!roleManager.isRestakeManagerAdmin(msg.sender)) revert NotRestakeManagerAdmin();\n        _;\n    }\n\n    event RewardDestinationUpdated(\n        address rewardDestination        \n    );\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(IRoleManager _roleManager, address _rewardDestination) public initializer {\n        __ReentrancyGuard_init();\n\n        if(address(_roleManager) == address(0x0)) revert InvalidZeroInput(); \n        if(address(_rewardDestination) == address(0x0)) revert InvalidZeroInput(); \n        \n        roleManager = _roleManager;   \n        rewardDestination = _rewardDestination;\n\n        emit RewardDestinationUpdated(_rewardDestination);\n    }\n\n    /// @dev Handle ETH sent to this contract from outside the protocol - e.g. rewards\n    receive() external payable nonReentrant { \n    }\n\n    /// @dev Forwards all native ETH rewards to the DepositQueue contract\n    function forwardRewards() external nonReentrant onlyNativeEthRestakeAdmin {\n        uint256 balance = address(this).balance;\n        if(balance == 0) {\n          return;\n        }\n\n        (bool success, ) = rewardDestination.call{value: balance}(\"\");\n        if(!success) revert TransferFailed();\n    }\n\n    function setRewardDestination(address _rewardDestination) external nonReentrant onlyRestakeManagerAdmin {\n        if(address(_rewardDestination) == address(0x0)) revert InvalidZeroInput(); \n\n        rewardDestination = _rewardDestination;\n\n        emit RewardDestinationUpdated(_rewardDestination);\n    }\n}"
    },
    "contracts/Rewards/RewardHandlerStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.19;\n\nimport \"../Permissions/IRoleManager.sol\";\n\nabstract contract RewardHandlerStorageV1 {    \n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev the address of the depositQueue contract\n    address public rewardDestination;\n}\n"
    },
    "contracts/Test/ITestingEigenpodManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ITestingEigenpodManager {  \n  function recordBeaconChainETHBalanceUpdate(address podOwner, int256 sharesDelta) external;\n}"
    },
    "contracts/Test/TestingDelegationManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"../EigenLayer/interfaces/IStrategy.sol\";\nimport \"../EigenLayer/interfaces/IStrategyManager.sol\";\nimport \"./TestingStrategy.sol\";\nimport \"../EigenLayer/interfaces/IDelegationManager.sol\";\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingDelegationManager {\n    function calculateWithdrawalRoot(\n        IStrategyManager.QueuedWithdrawal memory withdrawal\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(withdrawal));\n    }\n\n    uint256 constant withdrawBlockWait = 100;\n    mapping(bytes32 => bool) public pendingWithdrawals;\n    mapping(address => uint256) public cumulativeWithdrawalsQueued;\n\n    function delegateTo(\n        address operator\n    ) external {\n        // go through the internal delegation flow, checking the `approverSignatureAndExpiry` if applicable\n        // shhh\n    }\n\n}\n"
    },
    "contracts/Test/TestingEigenpod.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"./ITestingEigenpodManager.sol\";\nimport \"../EigenLayer/libraries/BeaconChainProofs.sol\";\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingEigenpod {\n\n  ITestingEigenpodManager eigenpodManager;\n\n  // constructor\n  constructor(ITestingEigenpodManager _eigenpodManager) {\n    eigenpodManager = _eigenpodManager;\n  }\n\n  function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable {\n  }\n\n  function verifyWithdrawalCredentials(\n        uint64 ,\n        uint40 ,\n        BeaconChainProofs.ValidatorFieldsAndBalanceProofs memory ,\n        bytes32[] calldata \n  ) external {\n    eigenpodManager.recordBeaconChainETHBalanceUpdate(msg.sender, 32 ether);\n  }\n\n  // Allow sending ETH to simulate staking rewards\n  receive() external payable {\n  }\n  \n}"
    },
    "contracts/Test/TestingEigenpodManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"./TestingEigenpod.sol\";\nimport \"./ITestingEigenpodManager.sol\";\nimport \"./TestingStrategyManager.sol\";\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingEigenpodManager is ITestingEigenpodManager{\n  mapping (address => address) eigenpodsToOwners;\n  mapping(address => int256) public podOwnerShares;\n  TestingStrategyManager testingStrategyManager;\n\n  constructor(TestingStrategyManager _testingStrategyManager) {\n    testingStrategyManager = _testingStrategyManager;\n  }\n\n  function createPod() external{\n    TestingEigenpod pod = new TestingEigenpod(this);\n    eigenpodsToOwners[msg.sender] = address(pod);\n  }\n\n  function ownerToPod(address podOwner) external view returns (address){\n    return eigenpodsToOwners[podOwner];\n  }\n\n  function stake(bytes calldata pubkey, bytes calldata signature, bytes32 depositDataRoot) external payable {\n    TestingEigenpod pod = TestingEigenpod(payable(eigenpodsToOwners[msg.sender]));\n    pod.stake{value: msg.value}(pubkey, signature, depositDataRoot);\n  }\n\n  function recordBeaconChainETHBalanceUpdate(address podOwner, int256 sharesDelta) external {\n    podOwnerShares[podOwner] += sharesDelta;\n    testingStrategyManager.setStakeryStrategyShares(podOwner, uint256(podOwnerShares[podOwner]));\n  }\n\n}"
    },
    "contracts/Test/TestingOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingOracle {\n\n  uint80 roundId; \n  int256 answer;\n  uint256 startedAt;\n  uint256 updatedAt;\n  uint80 answeredInRound;\n\n  uint8 public internalDecimals;\n\n  constructor() {\n        internalDecimals = 18;\n    }\n\n  function setLatestRoundData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _startedAt,\n    uint256 _updatedAt,\n    uint80 _answeredInRound\n    ) external\n  {\n    roundId = _roundId;\n    answer = _answer;\n    startedAt = _startedAt;\n    updatedAt = _updatedAt;\n    answeredInRound = _answeredInRound;\n  }\n  \n\nfunction latestRoundData()\n    external\n    view\n    returns (uint80 _roundId, int256 _answer, uint256 _startedAt, uint256 _updatedAt, uint80 _answeredInRound){\n      return (roundId, answer, startedAt, updatedAt, answeredInRound);\n    }\n\n  function setDecimals(uint8 _decimals) external {\n    internalDecimals = _decimals;\n  }\n\n  function decimals() external view returns (uint8){\n    return internalDecimals;\n  }\n\n}"
    },
    "contracts/Test/TestingStrategy.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"../EigenLayer/interfaces/IStrategy.sol\";\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingStrategy {\n\n  uint256 public underlyingTokens;\n  function setUnderlyingTokens(uint256 _tokens) external {\n    underlyingTokens = _tokens;\n  }\n\n  uint256 public shares;\n  function setShares(uint256 _shares) external {\n    shares = _shares;\n  }\n\n  /// @dev uses the ratio of underlying tokens to shares to calculate the amount of underlying shares to return\n  function underlyingToSharesView(uint256 amountUnderlying) external view returns (uint256){\n    return amountUnderlying * underlyingTokens / shares;\n  }\n\n  function sharesToUnderlyingView(uint256 _shares) external view returns (uint256){\n    return _shares * shares / underlyingTokens;\n  }\n\n  // Track the number of tokens deposited into this strategy by each account\n  mapping(address => uint256) public accountTokens;\n  function setAccountTokens(address _account, uint256 _tokens) external {\n    accountTokens[_account] = _tokens;\n  }\n\n  function withdrawTokens( IERC20 token, address _destination, uint256 amount) external {\n    token.transfer(_destination, amount);\n  }\n\n  function userUnderlyingView(address user) external view returns (uint256) {\n    return accountTokens[user]; \n  }\n\n}"
    },
    "contracts/Test/TestingStrategyManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"../EigenLayer/interfaces/IStrategy.sol\";\nimport \"./TestingStrategy.sol\";\nimport \"../EigenLayer/interfaces/IStrategyManager.sol\";\n\n/// @dev this is just a contract to use in unit testing - allows setting return values and mimics minimal logic\ncontract TestingStrategyManager {\n    uint256 public depositIntoStrategyReturnValue;\n    mapping(address => IStrategy[]) public stakerStrategyList;\n\n    function setDepositIntoStrategyReturnValue(uint256 _returnValue) external {\n        depositIntoStrategyReturnValue = _returnValue;\n    }\n\n    function stakerStrategyListLength(\n        address _staker\n    ) external view returns (uint256) {\n        return stakerStrategyList[_staker].length;\n    }\n\n    ///\n    function depositIntoStrategy(\n        IStrategy strategy,\n        IERC20 token,\n        uint256 amount\n    ) external returns (uint256 shares) {\n        // Transfer tokens into this strategy\n        token.transferFrom(msg.sender, address(strategy), amount);\n\n        // Calculate the number of tokens and shares\n        TestingStrategy testingStrategy = TestingStrategy(address(strategy));\n        uint256 existingTokens = testingStrategy.underlyingTokens();\n        uint256 existingShares = testingStrategy.shares();\n\n        // If either is 0, just add them both as the value\n        if (existingShares == 0 || existingTokens == 0) {\n            testingStrategy.setUnderlyingTokens(amount);\n            testingStrategy.setShares(amount);\n        } else {\n            testingStrategy.setUnderlyingTokens(existingTokens + amount);\n            testingStrategy.setShares(\n                existingShares + (amount * existingShares) / existingTokens\n            );\n        }\n\n        // Get the number of tokens for the account\n        uint256 accountTokens = testingStrategy.accountTokens(msg.sender);\n\n        // Update it with the new amount\n        testingStrategy.setAccountTokens(msg.sender, accountTokens + amount);\n\n        // Add the strategy to the staker if it doesn't exist\n        bool found = false;\n        for (uint8 i = 0; i < stakerStrategyList[msg.sender].length; i++) {\n            if (stakerStrategyList[msg.sender][i] == strategy) {\n                found = true;\n                break;\n            }\n        }\n\n        // Add it if not found\n        if (!found) {\n            stakerStrategyList[msg.sender].push(strategy);\n        }\n\n        return depositIntoStrategyReturnValue;\n    }\n\n    function calculateWithdrawalRoot(IStrategyManager.QueuedWithdrawal memory queuedWithdrawal) public pure returns (bytes32) {\n        return (\n            keccak256(\n                abi.encode(\n                    queuedWithdrawal.strategies,\n                    queuedWithdrawal.shares,\n                    queuedWithdrawal.depositor,\n                    queuedWithdrawal.withdrawerAndNonce,\n                    queuedWithdrawal.withdrawalStartBlock,\n                    queuedWithdrawal.delegatedAddress\n                )\n            )\n        );\n    }\n\n    uint256 constant withdrawBlockWait = 100;\n    mapping(bytes32 => IStrategyManager.QueuedWithdrawal) public pendingWithdrawals;\n    mapping(address => uint256) public numWithdrawalsQueued;\n    mapping(address => mapping(IStrategy => uint256)) public stakerStrategyShares;\n    IStrategy public constant beaconChainETHStrategy = IStrategy(0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0);\n\n    function setStakeryStrategyShares(address staker, uint256 shares) external {\n        stakerStrategyShares[staker][beaconChainETHStrategy] = shares;\n    }\n\n    function queueWithdrawal(\n        uint256[] calldata,\n        IStrategy[] calldata strategies,\n        uint256[] calldata shares,\n        address withdrawer,\n        bool\n    )\n        external returns(bytes32){\n          require(shares.length == strategies.length, \"invalid array lengths\");\n          require(shares.length == 1, \"only supports 1 strategy\");\n\n          TestingStrategy testingStrategy = TestingStrategy(address(strategies[0]));\n\n          // Get the number of underlying from shares\n          uint256 underlyingTokens = testingStrategy.sharesToUnderlyingView(shares[0]);\n\n          // Get the accounts token amount\n          uint256 existingTokenBalance = testingStrategy.accountTokens(msg.sender);\n          require(existingTokenBalance >= underlyingTokens, \"insufficient tokens\");\n\n         IStrategyManager.WithdrawerAndNonce memory withdrawerAndNonce = IStrategyManager.WithdrawerAndNonce({\n                withdrawer: withdrawer,\n                nonce: uint96(numWithdrawalsQueued[withdrawer])\n            });\n          \n          numWithdrawalsQueued[withdrawer] = numWithdrawalsQueued[withdrawer] + 1;\n\n          // Get the queued withdrawal object\n          IStrategyManager.QueuedWithdrawal memory queuedWithdrawal = IStrategyManager.QueuedWithdrawal({\n                strategies: strategies,\n                shares: shares,\n                depositor: msg.sender,\n                withdrawerAndNonce: withdrawerAndNonce,\n                withdrawalStartBlock: uint32(block.number),\n                delegatedAddress: address(0x0) // TODO: handle delegations\n            });\n\n          // Calculate the hash\n          bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n          // Set the queued withdrawal\n          pendingWithdrawals[withdrawalRoot] = queuedWithdrawal;\n\n          return withdrawalRoot;\n        }\n    \n    function completeQueuedWithdrawal(\n        IStrategyManager.QueuedWithdrawal calldata queuedWithdrawal,\n        IERC20[] calldata tokens,\n        uint256,\n        bool\n    )\n        external{          \n          // Calculate the withdrawalRoot\n          bytes32 withdrawalRoot = calculateWithdrawalRoot(queuedWithdrawal);\n\n          // Verify it exists\n          require(pendingWithdrawals[withdrawalRoot].withdrawalStartBlock != 0, \"withdrawal not queued\");\n\n          // Verify the block wait has passed\n          require(block.number >= pendingWithdrawals[withdrawalRoot].withdrawalStartBlock + withdrawBlockWait, \"block wait not passed\");\n\n          // Get the strategy\n          TestingStrategy strategy = TestingStrategy(address(pendingWithdrawals[withdrawalRoot].strategies[0])); \n\n          // Get the current underlying tokens\n          uint256 underlyingTokens = strategy.underlyingTokens();\n\n          // Get the current shares\n          uint256 shares = strategy.shares();\n\n          // Get the token amount from strategy\n          uint256 underlyingTokensToWithdraw = strategy.sharesToUnderlyingView(pendingWithdrawals[withdrawalRoot].shares[0]);\n\n          // Pull the tokens from the strategy\n          strategy.withdrawTokens(tokens[0], queuedWithdrawal.withdrawerAndNonce.withdrawer, underlyingTokensToWithdraw);\n\n          // Set the updated tokens\n          strategy.setUnderlyingTokens(underlyingTokens - underlyingTokensToWithdraw);\n          \n          // Set the updated shares\n          strategy.setShares(shares - pendingWithdrawals[withdrawalRoot].shares[0]);\n        }\n}\n"
    },
    "contracts/Test/TestToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @title TestErc20\n/// @dev This contract implements the ERC20 standard and is used for unit testing purposes only\n/// Anyone can mint tokens\ncontract TestErc20 is ERC20Upgradeable {\n    uint8 private internalDecimals;\n\n    /// @dev initializer to call after deployment, can only be called once\n    function initialize(string memory name_, string memory symbol_)\n        public\n        initializer\n    {\n        __ERC20_init(name_, symbol_);\n        internalDecimals = 18;\n    }\n\n    function mint(address to, uint256 amount) public virtual {\n        _mint(to, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return internalDecimals;\n    }\n\n    function setDecimals(uint8 _decimalsToSet) public {\n        internalDecimals = _decimalsToSet;\n    }\n}\n"
    },
    "contracts/token/EzEthToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"./IEzEthToken.sol\";\nimport \"../Permissions/IRoleManager.sol\";\nimport \"./EzEthTokenStorage.sol\";\nimport \"../Errors/Errors.sol\";\n\n/// @dev This contract is the ezETH ERC20 token\n/// Ownership of the collateral in the protocol is tracked by the ezETH token\ncontract EzEthToken is    \n    Initializable,\n    ERC20Upgradeable,\n    IEzEthToken, \n    EzEthTokenStorageV1\n{\n    /// @dev Allows only a whitelisted address to mint or burn ezETH tokens\n    modifier onlyMinterBurner() {\n        if(!roleManager.isEzETHMinterBurner(msg.sender)) revert NotEzETHMinterBurner();\n        _;\n    }\n\n    /// @dev Allows only a whitelisted address to pause or unpause the token\n    modifier onlyTokenAdmin() {\n        if(!roleManager.isTokenAdmin(msg.sender)) revert NotTokenAdmin();\n        _;\n    }\n\n    /// @dev Prevents implementation contract from being initialized.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /// @dev Initializes the contract with initial vars\n    function initialize(IRoleManager _roleManager) public initializer {\n        if(address(_roleManager) == address(0x0)) revert InvalidZeroInput();\n\n        __ERC20_init(\"ezETH\", \"Renzo Restaked ETH\");\n        roleManager = _roleManager;\n    }\n\n    /// @dev Allows minter/burner to mint new ezETH tokens to an address\n    function mint(address to, uint256 amount) external onlyMinterBurner {\n        _mint(to, amount);\n    }\n\n    /// @dev Allows minter/burner to burn ezETH tokens from an address\n    function burn(address from, uint256 amount) external onlyMinterBurner {\n        _burn(from, amount);\n    }\n\n    /// @dev Sets the paused flag\n    function setPaused(bool _paused) external onlyTokenAdmin {\n        paused = _paused;\n    }\n\n    /// @dev \n    function _beforeTokenTransfer(address from, address to, uint256 amount)\n        internal virtual override\n    {\n        super._beforeTokenTransfer(from, to, amount);\n\n        // If not paused return success\n        if (!paused) {\n            return;\n        }\n\n        // If paused, only minting and burning should be allowed\n        if (from != address(0) && to != address(0)) {\n            revert ContractPaused();\n        }\n    }\n}\n"
    },
    "contracts/token/EzEthTokenStorage.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\nimport \"../Permissions/IRoleManager.sol\";\n\n/// @title EzEthTokenStorage\n/// @dev This contract will hold all local variables for the  Contract\n/// When upgrading the protocol, inherit from this contract on the V2 version and change the\n/// StorageManager to inherit from the later version.  This ensures there are no storage layout\n/// corruptions when upgrading.\ncontract EzEthTokenStorageV1 {\n    /// @dev reference to the RoleManager contract\n    IRoleManager public roleManager;\n\n    /// @dev flag to control whether transfers are paused\n    bool public paused;\n\n}\n\n/// On the next version of the protocol, if new variables are added, put them in the below\n/// contract and use this as the inheritance chain.\n/**\ncontract EzEthTokenStorageV2 is EzEthTokenStorageV1 {\n  address newVariable;\n}\n */\n"
    },
    "contracts/token/IEzEthToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IEzEthToken is IERC20Upgradeable {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}